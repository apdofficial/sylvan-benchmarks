aag 423 15 28 1 380
2
4
6
8
10
12
14
16
18
20
22
24
26
28
30
32 1
34 499
36 583
38 14
40 607
42 28
44 627
46 2
48 24
50 8
52 4
54 657
56 679
58 30
60 703
62 6
64 741
66 747
68 753
70 22
72 835
74 841
76 847
78 99
80 18
82 26
84 20
86 16
392
88 18 3
90 22 5
92 91 89
94 79 32
96 95 32
98 97 92
100 25 2
102 24 3
104 103 101
106 105 17
108 25 4
110 24 5
112 111 109
114 113 16
116 115 107
118 83 32
120 82 32
122 119 32
124 123 9
126 125 116
128 55 32
130 54 32
132 129 32
134 130 9
136 135 126
138 37 32
140 36 32
142 139 32
144 41 32
146 40 32
148 145 32
150 149 143
152 45 32
154 44 32
156 153 32
158 157 150
160 159 9
162 161 136
164 59 32
166 58 32
168 165 32
170 166 17
172 169 16
174 173 171
176 175 120
178 177 162
180 85 32
182 84 32
184 181 32
186 185 16
188 182 17
190 189 187
192 191 120
194 193 178
196 39 32
198 38 32
200 197 32
202 198 7
204 201 6
206 205 203
208 207 120
210 209 194
212 87 32
214 86 32
216 213 32
218 214 17
220 217 16
222 221 219
224 223 8
226 225 210
228 226 225
230 63 32
232 62 32
234 231 32
236 235 6
238 232 7
240 239 237
242 241 8
244 243 228
246 43 32
248 42 32
250 247 32
252 81 32
254 80 32
256 253 32
258 254 251
260 258 31
262 260 15
264 263 244
266 257 251
268 266 31
270 268 14
272 271 264
274 71 32
276 70 32
278 275 32
280 276 251
282 280 20
284 282 15
286 285 272
288 279 251
290 288 20
292 290 14
294 293 286
296 169 30
298 166 31
300 299 297
302 301 248
304 303 294
306 182 21
308 185 20
310 309 307
312 311 248
314 313 304
316 198 15
318 201 14
320 319 317
322 321 248
324 323 314
326 57 32
328 56 32
330 327 32
332 20 5
334 332 328
336 335 324
338 47 32
340 339 32
342 53 32
344 343 32
346 345 341
348 346 251
350 348 30
352 351 336
354 77 32
356 76 32
358 355 32
360 75 32
362 74 32
364 361 32
366 73 32
368 72 32
370 367 32
372 365 359
374 373 358
376 374 364
378 364 359
380 365 356
382 381 379
384 369 364
386 384 382
388 387 377
390 388 352
392 391 98
394 65 32
396 64 32
398 395 32
400 67 32
402 66 32
404 401 32
406 68 32
408 403 397
410 408 407
412 410 133
414 403 398
416 414 407
418 416 158
420 404 397
422 420 407
424 16 2
426 425 422
428 404 398
430 428 407
432 17 4
434 433 430
436 35 32
438 34 32
440 437 32
442 61 32
444 60 32
446 443 32
448 447 441
450 438 26
452 418 413
454 453 413
456 419 413
458 456 426
460 459 454
462 456 427
464 462 434
466 465 460
468 462 435
470 468 448
472 471 466
474 468 449
476 474 450
478 477 472
480 451 438
482 480 449
484 483 449
486 485 435
488 486 427
490 488 419
492 490 413
494 492 479
496 478 438
498 497 495
500 158 6
502 500 9
504 502 13
506 504 10
508 506 27
510 506 26
512 149 140
514 512 157
516 514 26
518 146 143
520 518 157
522 520 26
524 146 140
526 524 157
528 526 26
530 154 150
532 530 26
534 510 509
536 535 509
538 511 509
540 538 516
542 541 536
544 538 517
546 544 522
548 547 542
550 544 523
552 550 528
554 553 548
556 550 529
558 556 532
560 559 554
562 533 140
564 562 529
566 564 523
568 567 523
570 569 517
572 570 511
574 572 509
576 575 509
578 577 561
580 560 140
582 581 579
584 533 146
586 584 529
588 586 523
590 589 523
592 591 517
594 593 517
596 595 511
598 597 511
600 599 509
602 600 561
604 560 146
606 605 603
608 533 154
610 608 529
612 611 529
614 613 523
616 614 517
618 616 511
620 618 509
622 620 561
624 560 154
626 625 623
628 9 6
630 628 13
632 630 11
634 632 133
636 130 25
638 637 635
640 633 130
642 641 633
644 130 24
646 643 133
648 644 130
650 649 647
652 651 639
654 638 130
656 655 653
658 331 21
660 658 5
662 328 4
664 662 661
666 665 661
668 663 328
670 668 661
672 671 661
674 673 667
676 666 328
678 677 675
680 447 6
682 680 13
684 682 11
686 444 25
688 686 685
690 689 685
692 687 444
694 692 685
696 695 685
698 697 691
700 690 444
702 701 699
704 435 396
706 704 427
708 707 427
710 709 419
712 710 413
714 713 413
716 435 402
718 716 427
720 719 427
722 721 419
724 723 419
726 725 413
728 435 406
730 728 427
732 730 419
734 732 413
736 715 467
738 466 396
740 739 737
742 726 467
744 466 402
746 745 743
748 734 467
750 466 406
752 751 749
754 477 466
756 450 371
758 451 368
760 759 757
762 448 368
764 761 449
766 765 763
768 767 435
770 768 427
772 770 419
774 772 413
776 368 365
778 369 362
780 779 777
782 781 450
784 451 362
786 785 783
788 448 362
790 787 449
792 791 789
794 793 435
796 794 427
798 796 419
800 798 413
802 368 362
804 802 359
806 803 356
808 807 805
810 809 450
812 451 356
814 813 811
816 448 356
818 815 449
820 819 817
822 821 435
824 822 427
826 824 419
828 826 413
830 774 755
832 754 368
834 833 831
836 800 755
838 754 362
840 839 837
842 828 755
844 754 356
846 845 843
i0 i_hbusreq0
i1 i_hbusreq1
i2 controllable_hmastlock
i3 controllable_nstart
i4 i_hburst1
i5 i_hburst0
i6 controllable_locked
i7 controllable_hmaster0
i8 i_hlock0
i9 controllable_hgrant1
i10 i_hlock1
i11 controllable_busreq
i12 i_hready
i13 controllable_ndecide
i14 controllable_nhgrant0
l0 n33
l1 next_env_fair_out
l2 reg_stateG3_0_out
l3 reg_controllable_locked_out
l4 reg_stateG3_1_out
l5 reg_controllable_ndecide_out
l6 reg_stateG3_2_out
l7 reg_i_hbusreq0_out
l8 reg_controllable_busreq_out
l9 reg_controllable_nstart_out
l10 reg_i_hbusreq1_out
l11 reg_stateG2_out
l12 reg_stateG10_1_out
l13 reg_controllable_nhgrant0_out
l14 reg_stateA1_out
l15 reg_controllable_hmastlock_out
l16 next_sys_fair<0>_out
l17 next_sys_fair<1>_out
l18 next_sys_fair<2>_out
l19 reg_i_hlock1_out
l20 fair_cnt<0>_out
l21 fair_cnt<1>_out
l22 fair_cnt<2>_out
l23 env_safe_err_happened_out
l24 reg_i_hlock0_out
l25 reg_i_hready_out
l26 reg_controllable_hgrant1_out
l27 reg_controllable_hmaster0_out
o0 o_err
c
amba_2_new_6
This file was written by ABC on Sat Aug 31 20:24:47 2013
For information about AIGER format, refer to http://fmv.jku.at/aiger
-------------------------------
This AIGER file has been created by the following sequence of commands:
> vl2mv amba2c6unreal.v   ---gives--> amba2c6unreal.mv
> abc -c "read_blif_mv amba2c6unreal.mv; write_aiger -s amba2c6unrealn.aig"   ---gives--> amba2c6unrealn.aig
> aigtoaig amba2c6unrealn.aig amba2c6unrealn.aag   ---gives--> amba2c6unrealn.aag (this file)
Content of amba2c6unreal.v:
module amba_2_new_6(
        o_err,
        i_clk,
        i_hready,
        i_hbusreq0,
        i_hlock0,
        i_hbusreq1,
        i_hlock1,
        i_hburst0,
        i_hburst1,
        controllable_hmaster0,
        controllable_hmastlock,
        controllable_nstart,
        controllable_ndecide,
        controllable_locked,
        controllable_nhgrant0,
        controllable_hgrant1,
        controllable_busreq);

input i_clk;
input i_hready;
input i_hbusreq0;
input i_hlock0;
input i_hbusreq1;
input i_hlock1;
input i_hburst0;
input i_hburst1;
input controllable_hmaster0;
input controllable_hmastlock;
input controllable_nstart;
input controllable_ndecide;
input controllable_locked;
input controllable_nhgrant0;
input controllable_hgrant1;
input controllable_busreq;
output o_err;

reg reg_i_hready;
reg reg_i_hbusreq0;
reg reg_i_hlock0;
reg reg_i_hbusreq1;
reg reg_i_hlock1;
reg reg_controllable_hmaster0;
reg reg_controllable_hmastlock;
reg reg_controllable_nstart;
reg reg_controllable_ndecide;
reg reg_controllable_locked;
reg reg_controllable_nhgrant0;
reg reg_controllable_hgrant1;
reg reg_controllable_busreq;
reg reg_stateA1;
reg reg_stateG2;
reg reg_stateG3_0;
reg reg_stateG3_1;
reg reg_stateG3_2;
reg reg_stateG10_1;
reg env_safe_err_happened;
reg next_env_fair;
reg [2:0] fair_cnt;
reg [2:0] next_sys_fair;

wire env_safe_err0;
wire env_safe_err1;
wire env_safe_err;

wire sys_safe_err0;
wire sys_safe_err1;
wire sys_safe_err2;
wire sys_safe_err3;
wire sys_safe_err4;
wire sys_safe_err5;
wire sys_safe_err6;
wire sys_safe_err7;
wire sys_safe_err8;
wire sys_safe_err9;
wire sys_safe_err10;
wire sys_safe_err11;
wire sys_safe_err12;
wire sys_safe_err13;
wire sys_safe_err14;
wire sys_safe_err15;
wire sys_safe_err16;
wire sys_safe_err17;
wire sys_safe_err18;
wire sys_safe_err19;
wire sys_safe_err;

wire env_fair0;
wire env_fair1;

wire sys_fair0;
wire sys_fair1;
wire sys_fair2;
wire sys_fair3;
wire fair_err;
wire o_err;

// =============================================================
//                        ENV_TRANSITION:
// =============================================================
// Assumption 3:
// G( hlock0=1 -> hbusreq0=1 );
assign env_safe_err0 =  ~(~ i_hlock0 | i_hbusreq0);

// Assumption 3:
// G( hlock1=1 -> hbusreq1=1 );
assign env_safe_err1 =  ~(~ i_hlock1 | i_hbusreq1);

// collecting together the safety error bits:
assign env_safe_err = env_safe_err0 |
                      env_safe_err1;

// =============================================================
//                        SYS_TRANSITION:
// =============================================================
// G((hmaster0=0) -> (hbusreq0=0 <-> busreq=0));
assign sys_safe_err0 =  ~( ~( ~(controllable_hmaster0) )|(~i_hbusreq0 ^~ (~controllable_busreq)));

// G((hmaster0=1) -> (hbusreq1=0 <-> busreq=0));
assign sys_safe_err1 =  ~( ~( controllable_hmaster0 )|(~i_hbusreq1 ^~ (~controllable_busreq)));

// Guarantee 1:
// G((hready=0) -> X(start=0));
assign sys_safe_err2 =  ~( reg_i_hready | controllable_nstart );

// G(((stateG2=1) * (start=1)) -> FALSE;
assign sys_safe_err3 =  ~( ~(reg_stateG2 & ~controllable_nstart) | 0 );

// G(((stateG3_0=1) * (stateG3_1=0) * (stateG3_2=0) * ((start=1))) -> FALSE);
// G(((stateG3_0=0) * (stateG3_1=1) * (stateG3_2=0) * ((start=1))) -> FALSE);
// G(((stateG3_0=1) * (stateG3_1=1) * (stateG3_2=0) * ((start=1))) -> FALSE);
// G(((stateG3_0=0) * (stateG3_1=0) * (stateG3_2=1) * ((start=1))) -> FALSE);
// all these rules can be summarized as: only in state 000, start=1 is allowed:
assign sys_safe_err4 =  (reg_stateG3_0 | reg_stateG3_1 | reg_stateG3_2) & ~controllable_nstart;

// G( (hready=1) -> (   (hgrant0=1) <-> (X(hmaster0=0))  ) );
assign sys_safe_err5 =  ~( ~(reg_i_hready) | ( ~reg_controllable_nhgrant0 ^~ ( ~(controllable_hmaster0) ) ) );

// G( (hready=1) -> (   (hgrant1=1) <-> (X(hmaster0=1))  ) );
assign sys_safe_err6 =  ~( ~(reg_i_hready) | ( reg_controllable_hgrant1 ^~ ( controllable_hmaster0 ) ) );

// HMASTLOCK:
// G(  (hready=1) -> (locked=0 <-> X(hmastlock=0) ) );
assign sys_safe_err7 =  ~( ~(reg_i_hready) | (~reg_controllable_locked ^~ ~controllable_hmastlock) );

// Master 0:
// G( X(start=0) -> ( ((hmaster0=0)) <-> (X(hmaster0=0)) ) );
assign sys_safe_err8 =  ~( ~(controllable_nstart) | ( ( ~(reg_controllable_hmaster0) ) ^~ ( ~(controllable_hmaster0) )) );

// Master 1:
// G( X(start=0) -> ( ((hmaster0=1)) <-> (X(hmaster0=1)) ) );
assign sys_safe_err9 =  ~( ~(controllable_nstart) | ( ( reg_controllable_hmaster0 ) ^~ ( controllable_hmaster0 )) );

// Guarantee 6.2:
// G( ((X(start=0))) -> ( (hmastlock=1) <-> X(hmastlock=1)) );
assign sys_safe_err10 =  ~( ~(controllable_nstart) | ( reg_controllable_hmastlock ^~ controllable_hmastlock) );

// G( (decide=1  *  hlock0=1  *  X(hgrant0=1) )->X(locked=1));
assign sys_safe_err11 =  ~( ~(~reg_controllable_ndecide & reg_i_hlock0 & ~controllable_nhgrant0) | (controllable_locked) );

// G((decide=1  *  hlock0=0  *  X(hgrant0=1))->X(locked=0));
assign sys_safe_err12 =  ~( ~(~reg_controllable_ndecide & ~reg_i_hlock0 & ~controllable_nhgrant0) | (~controllable_locked) );

// G( (decide=1  *  hlock1=1  *  X(hgrant1=1) )->X(locked=1));
assign sys_safe_err13 =  ~( ~(~reg_controllable_ndecide & reg_i_hlock1 & controllable_hgrant1) | (controllable_locked) );

// G((decide=1  *  hlock1=0  *  X(hgrant1=1))->X(locked=0));
assign sys_safe_err14 =  ~( ~(~reg_controllable_ndecide & ~reg_i_hlock1 & controllable_hgrant1) | (~controllable_locked) );

// G( (decide=0) -> (  ((hgrant0=0)<->X(hgrant0=0))  ));
assign sys_safe_err15 =  ~( ~(reg_controllable_ndecide) | (reg_controllable_nhgrant0 ^~ controllable_nhgrant0) );

// G( (decide=0) -> (  ((hgrant1=0)<->X(hgrant1=0))  ));
assign sys_safe_err16 =  ~( ~(reg_controllable_ndecide) | (~reg_controllable_hgrant1 ^~ ~controllable_hgrant1) );

// G((decide=0)->(locked=0 <-> X(locked=0)));
assign sys_safe_err17 =  ~( ~(reg_controllable_ndecide) | (~reg_controllable_locked ^~ ~controllable_locked) );

// G(((stateG10_1=1) * (((hgrant1=1)) * (hbusreq1=0)))->FALSE);
assign sys_safe_err18 =  ~( ~(reg_stateG10_1 & (controllable_hgrant1 & ~i_hbusreq1)) | 0 );

// default master
// G((decide=1  *  hbusreq0=0  *  hbusreq1=0) -> X(hgrant0=1));
assign sys_safe_err19 =  ~( ~(~reg_controllable_ndecide & (~reg_i_hbusreq0 & ~reg_i_hbusreq1)) | (~controllable_nhgrant0) );

// collecting together the safety error bits:
assign sys_safe_err = sys_safe_err0 |
                      sys_safe_err1 |
                      sys_safe_err2 |
                      sys_safe_err3 |
                      sys_safe_err4 |
                      sys_safe_err5 |
                      sys_safe_err6 |
                      sys_safe_err7 |
                      sys_safe_err8 |
                      sys_safe_err9 |
                      sys_safe_err10 |
                      sys_safe_err11 |
                      sys_safe_err12 |
                      sys_safe_err13 |
                      sys_safe_err14 |
                      sys_safe_err15 |
                      sys_safe_err16 |
                      sys_safe_err17 |
                      sys_safe_err18 |
                      sys_safe_err19;

// =============================================================
//                          ENV_FAIRNESS:
// =============================================================
// Assumption 1: 
// G(F(stateA1=0));
assign env_fair0 =  ~reg_stateA1;

// Assumption 2:
// G(F(hready=1));
assign env_fair1 =  i_hready;


// =============================================================
//                          SYS_FAIRNESS:
// =============================================================
// Guarantee 2:
// G(F(stateG2=0));
assign sys_fair0 = ~reg_stateG2;

// Guarantee 3:
// G(F((stateG3_0=0)  *  (stateG3_1=0)  *  (stateG3_2=0)));
assign sys_fair1 =  (~reg_stateG3_0 & ~reg_stateG3_1 & ~reg_stateG3_2);

// G(F(((hmaster0=0))  |  hbusreq0=0));
assign sys_fair2 =  ( ~(controllable_hmaster0) ) | ~i_hbusreq0;

// G(F(((hmaster0=1))  |  hbusreq1=0));
assign sys_fair3 =  ( controllable_hmaster0 ) | ~i_hbusreq1;

assign fair_err = (fair_cnt >= 3'b110);

// computing the error output bit:
assign o_err = ~env_safe_err & ~env_safe_err_happened & (sys_safe_err | fair_err);

initial
 begin
  reg_i_hready = 0;
  reg_i_hbusreq0 = 0;
  reg_i_hlock0 = 0;
  reg_i_hbusreq1 = 0;
  reg_i_hlock1 = 0;
  reg_controllable_hmaster0 = 0;
  reg_controllable_hmastlock = 0;
  reg_controllable_nstart = 0;
  reg_controllable_ndecide = 0;
  reg_controllable_locked = 0;
  reg_controllable_nhgrant0 = 0;
  reg_controllable_hgrant1 = 0;
  reg_controllable_busreq = 0;
  reg_stateA1 = 0;
  reg_stateG2 = 0;
  reg_stateG3_0 = 0;
  reg_stateG3_1 = 0;
  reg_stateG3_2 = 0;
  reg_stateG10_1 = 0;
  env_safe_err_happened = 0;
  next_env_fair = 0;
  fair_cnt = 0;
  next_sys_fair = 0;
 end


always @(posedge i_clk)
 begin
   // We remember if an environment error occurred:
   env_safe_err_happened = env_safe_err_happened | env_safe_err;

   // Updating the fairness counters: 
   if((next_sys_fair == 0) & sys_fair0)
    begin
      next_sys_fair = 1;
      next_env_fair = 0;
      fair_cnt = 0;
    end
   else if((next_sys_fair == 1) & sys_fair1)
    begin
      next_sys_fair = 2;
      next_env_fair = 0;
      fair_cnt = 0;
    end
   else if((next_sys_fair == 2) & sys_fair2)
    begin
      next_sys_fair = 3;
      next_env_fair = 0;
      fair_cnt = 0;
    end
   else if((next_sys_fair == 3) & sys_fair3)
    begin
      next_sys_fair = 0;
      next_env_fair = 0;
      fair_cnt = 0;
    end
   else if(~next_env_fair & env_fair0)
    begin
      next_env_fair = 1;
    end
   else if(next_env_fair & env_fair1)
    begin
      next_env_fair = 0;
      fair_cnt = fair_cnt + 1;
    end

   // Updating the automata: 
   // Automaton A1: 
   if(~reg_stateA1 & controllable_hmastlock & ~i_hburst0 & ~i_hburst1)
    begin
      reg_stateA1 = 1'b1;
    end
   else if(reg_stateA1 & ~controllable_busreq)
    begin
      reg_stateA1 = 1'b0;
    end

   // Automaton G2: 
   if(~reg_stateG2)
    begin
      if(controllable_hmastlock & ~controllable_nstart & ~i_hburst0 & ~i_hburst1)
       begin
         reg_stateG2 = 1'b1;
       end
    end
   else // if(reg_stateG2)
    begin
      if(~controllable_busreq)
       begin
         reg_stateG2 = 1'b0;
       end
    end

   // Automaton G3: 
   if(~reg_stateG3_0 & ~reg_stateG3_1 & ~reg_stateG3_2 & controllable_hmastlock & ~controllable_nstart &  ~i_hburst0 & i_hburst1 & ~i_hready)
    begin
      reg_stateG3_0 = 1'b1;
      reg_stateG3_1 = 1'b0;
      reg_stateG3_2 = 1'b0;
    end
   else if(~reg_stateG3_0 & ~reg_stateG3_1 & ~reg_stateG3_2 & controllable_hmastlock & ~controllable_nstart &  ~i_hburst0 & i_hburst1 & i_hready)
    begin
      reg_stateG3_0 = 1'b0;
      reg_stateG3_1 = 1'b1;
      reg_stateG3_2 = 1'b0;
    end
   else if(reg_stateG3_0 & ~reg_stateG3_1 & ~reg_stateG3_2 & i_hready)
    begin
      reg_stateG3_0 = 1'b0;
      reg_stateG3_1 = 1'b1;
      reg_stateG3_2 = 1'b0;
    end
   else if(~reg_stateG3_0 & reg_stateG3_1 & ~reg_stateG3_2 & i_hready)
    begin
      reg_stateG3_0 = 1'b1;
      reg_stateG3_1 = 1'b1;
      reg_stateG3_2 = 1'b0;
    end
   else if(reg_stateG3_0 & reg_stateG3_1 & ~reg_stateG3_2 & i_hready)
    begin
      reg_stateG3_0 = 1'b0;
      reg_stateG3_1 = 1'b0;
      reg_stateG3_2 = 1'b1;
    end
   else if(~reg_stateG3_0 & ~reg_stateG3_1 & reg_stateG3_2 & i_hready)
    begin
      reg_stateG3_0 = 1'b0;
      reg_stateG3_1 = 1'b0;
      reg_stateG3_2 = 1'b0;
    end

   // Automaton G10_1: 
   if(~reg_stateG10_1 & ~controllable_hgrant1 & ~i_hbusreq1)
    begin
      reg_stateG10_1 = 1'b1;
    end
   else if(reg_stateG10_1 & i_hbusreq1)
    begin
      reg_stateG10_1 = 1'b0;
    end

   // Latching the previous input:
   reg_i_hready =  i_hready;
   reg_i_hbusreq0 =  i_hbusreq0;
   reg_i_hlock0 =  i_hlock0;
   reg_i_hbusreq1 =  i_hbusreq1;
   reg_i_hlock1 =  i_hlock1;
   reg_controllable_hmaster0 =  controllable_hmaster0;
   reg_controllable_hmastlock =  controllable_hmastlock;
   reg_controllable_nstart =  controllable_nstart;
   reg_controllable_ndecide =  controllable_ndecide;
   reg_controllable_locked =  controllable_locked;
   reg_controllable_nhgrant0 =  controllable_nhgrant0;
   reg_controllable_hgrant1 =  controllable_hgrant1;
   reg_controllable_busreq =  controllable_busreq;

 end
endmodule

-------------------------------
#!SYNTCOMP
STATUS : unrealizable
SOLVED_BY : 7/8 [SYNTCOMP2014-RealSeq]
SOLVED_IN : 0.356021 [SYNTCOMP2014-RealSeq]
#.
