aag 226 15 29 1 182
2
4
6
8
10
12
14
16
18
20
22
24
26
28
30
32 1
34 340
36 363
38 14
40 381
42 28
44 387
46 2
48 24
50 8
52 4
54 395
56 398
58 30
60 409
62 6
64 415
66 419
68 290
70 22
72 428
74 436
76 444
78 452
80 99
82 18
84 26
86 20
88 16
288
90 18 3
92 22 5
94 93 91
96 80 32
98 97 94
100 82 32
102 42 32
104 103 100
106 104 31
108 106 15
110 25 4
112 24 5
114 113 111
116 115 16
118 25 2
120 24 3
122 121 119
124 123 17
126 84 32
128 38 32
130 128 7
132 129 6
134 133 131
136 86 32
138 58 32
140 138 16
142 141 136
144 139 17
146 145 137
148 147 143
150 148 134
152 151 126
154 36 32
156 40 32
158 157 155
160 44 32
162 161 158
164 54 32
166 165 126
168 166 162
170 168 9
172 88 32
174 172 17
176 173 16
178 177 175
180 62 32
182 181 6
184 180 7
186 185 183
188 186 178
190 188 8
192 191 171
194 193 153
196 194 125
198 196 117
200 198 109
202 103 101
204 202 31
206 204 14
208 207 200
210 70 32
212 210 103
214 212 20
216 214 15
218 217 208
220 211 103
222 220 20
224 222 14
226 225 218
228 139 30
230 138 31
232 231 229
234 233 102
236 235 226
238 136 21
240 137 20
242 241 239
244 243 102
246 245 236
248 128 15
250 129 14
252 251 249
254 253 102
256 255 246
258 56 32
260 20 5
262 260 258
264 263 256
266 53 47
268 267 32
270 269 103
272 270 30
274 273 264
276 76 32
278 74 32
280 278 276
282 78 32
284 282 280
286 285 274
288 287 98
290 68 32
292 64 32
294 66 32
296 294 292
298 296 291
300 17 4
302 301 298
304 295 293
306 304 291
308 306 165
310 294 293
312 310 291
314 16 2
316 315 312
318 295 292
320 318 291
322 320 162
324 323 317
326 324 309
328 326 303
330 34 32
332 330 26
334 60 32
336 334 331
338 337 333
340 338 328
342 9 6
344 342 13
346 344 162
348 346 10
350 348 27
352 161 26
354 353 155
356 352 154
358 357 355
360 358 159
362 361 351
364 348 26
366 156 154
368 366 161
370 368 26
372 371 156
374 157 154
376 374 352
378 377 373
380 378 365
382 158 26
384 383 160
386 385 371
388 164 24
390 165 11
392 390 344
394 393 389
396 259 20
398 397 5
400 335 6
402 13 11
404 402 400
406 334 24
408 407 405
410 328 292
412 317 309
414 412 411
416 328 294
418 417 324
420 72 32
422 420 332
424 421 333
426 425 423
428 426 328
430 423 279
432 422 278
434 433 431
436 434 328
438 433 277
440 432 276
442 441 439
444 442 328
446 441 283
448 440 282
450 449 447
452 450 328
i0 i_hbusreq0
i1 i_hbusreq1
i2 controllable_hmastlock
i3 controllable_nstart
i4 i_hburst1
i5 i_hburst0
i6 controllable_locked
i7 controllable_hmaster0
i8 i_hlock0
i9 controllable_hgrant1
i10 i_hlock1
i11 controllable_busreq
i12 i_hready
i13 controllable_ndecide
i14 controllable_nhgrant0
l0 n33
l1 next_env_fair_out
l2 reg_stateG3_0_out
l3 reg_controllable_locked_out
l4 reg_stateG3_1_out
l5 reg_controllable_ndecide_out
l6 reg_stateG3_2_out
l7 reg_i_hbusreq0_out
l8 reg_controllable_busreq_out
l9 reg_controllable_nstart_out
l10 reg_i_hbusreq1_out
l11 reg_stateG2_out
l12 reg_stateG10_1_out
l13 reg_controllable_nhgrant0_out
l14 reg_stateA1_out
l15 reg_controllable_hmastlock_out
l16 next_sys_fair<0>_out
l17 next_sys_fair<1>_out
l18 next_sys_fair<2>_out
l19 reg_i_hlock1_out
l20 fair_cnt<0>_out
l21 fair_cnt<1>_out
l22 fair_cnt<2>_out
l23 fair_cnt<3>_out
l24 env_safe_err_happened_out
l25 reg_i_hlock0_out
l26 reg_i_hready_out
l27 reg_controllable_hgrant1_out
l28 reg_controllable_hmaster0_out
o0 o_err
c
amba_2_new_14
This file was written by ABC on Tue May  5 16:51:03 2015
For information about AIGER format, refer to http://fmv.jku.at/aiger
-------------------------------
This AIGER file has been created by the following sequence of commands:
> vl2mv amba2c14.v   ---gives--> amba2c14.mv
> abc -c "read_blif_mv amba2c14.mv; strash; refactor; rewrite; dfraig; rewrite; dfraig; write_aiger -s amba2c14y.aig"   ---gives--> amba2c14y.aig
> aigtoaig amba2c14y.aig amba2c14y.aag   ---gives--> amba2c14y.aag (this file)
Content of amba2c14.v:
module amba_2_new_14(
        o_err,
        i_clk,
        i_hready,
        i_hbusreq0,
        i_hlock0,
        i_hbusreq1,
        i_hlock1,
        i_hburst0,
        i_hburst1,
        controllable_hmaster0,
        controllable_hmastlock,
        controllable_nstart,
        controllable_ndecide,
        controllable_locked,
        controllable_nhgrant0,
        controllable_hgrant1,
        controllable_busreq);

input i_clk;
input i_hready;
input i_hbusreq0;
input i_hlock0;
input i_hbusreq1;
input i_hlock1;
input i_hburst0;
input i_hburst1;
input controllable_hmaster0;
input controllable_hmastlock;
input controllable_nstart;
input controllable_ndecide;
input controllable_locked;
input controllable_nhgrant0;
input controllable_hgrant1;
input controllable_busreq;
output o_err;

reg reg_i_hready;
reg reg_i_hbusreq0;
reg reg_i_hlock0;
reg reg_i_hbusreq1;
reg reg_i_hlock1;
reg reg_controllable_hmaster0;
reg reg_controllable_hmastlock;
reg reg_controllable_nstart;
reg reg_controllable_ndecide;
reg reg_controllable_locked;
reg reg_controllable_nhgrant0;
reg reg_controllable_hgrant1;
reg reg_controllable_busreq;
reg reg_stateA1;
reg reg_stateG2;
reg reg_stateG3_0;
reg reg_stateG3_1;
reg reg_stateG3_2;
reg reg_stateG10_1;
reg env_safe_err_happened;
reg next_env_fair;
reg [3:0] fair_cnt;
reg [2:0] next_sys_fair;

wire env_safe_err0;
wire env_safe_err1;
wire env_safe_err;

wire sys_safe_err0;
wire sys_safe_err1;
wire sys_safe_err2;
wire sys_safe_err3;
wire sys_safe_err4;
wire sys_safe_err5;
wire sys_safe_err6;
wire sys_safe_err7;
wire sys_safe_err8;
wire sys_safe_err9;
wire sys_safe_err10;
wire sys_safe_err11;
wire sys_safe_err12;
wire sys_safe_err13;
wire sys_safe_err14;
wire sys_safe_err15;
wire sys_safe_err16;
wire sys_safe_err17;
wire sys_safe_err18;
wire sys_safe_err19;
wire sys_safe_err;

wire env_fair0;
wire env_fair1;

wire sys_fair0;
wire sys_fair1;
wire sys_fair2;
wire sys_fair3;
wire fair_err;
wire o_err;

// =============================================================
//                        ENV_TRANSITION:
// =============================================================
// Assumption 3:
// G( hlock0=1 -> hbusreq0=1 );
assign env_safe_err0 =  ~(~ i_hlock0 | i_hbusreq0);

// Assumption 3:
// G( hlock1=1 -> hbusreq1=1 );
assign env_safe_err1 =  ~(~ i_hlock1 | i_hbusreq1);

// collecting together the safety error bits:
assign env_safe_err = env_safe_err0 |
                      env_safe_err1;

// =============================================================
//                        SYS_TRANSITION:
// =============================================================
// G((hmaster0=0) -> (hbusreq0=0 <-> busreq=0));
assign sys_safe_err0 =  ~( ~( ~(controllable_hmaster0) )|(~i_hbusreq0 ^~ (~controllable_busreq)));

// G((hmaster0=1) -> (hbusreq1=0 <-> busreq=0));
assign sys_safe_err1 =  ~( ~( controllable_hmaster0 )|(~i_hbusreq1 ^~ (~controllable_busreq)));

// Guarantee 1:
// G((hready=0) -> X(start=0));
assign sys_safe_err2 =  ~( reg_i_hready | controllable_nstart );

// G(((stateG2=1) * (start=1)) -> FALSE;
assign sys_safe_err3 =  ~( ~(reg_stateG2 & ~controllable_nstart) | 0 );

// G(((stateG3_0=1) * (stateG3_1=0) * (stateG3_2=0) * ((start=1))) -> FALSE);
// G(((stateG3_0=0) * (stateG3_1=1) * (stateG3_2=0) * ((start=1))) -> FALSE);
// G(((stateG3_0=1) * (stateG3_1=1) * (stateG3_2=0) * ((start=1))) -> FALSE);
// G(((stateG3_0=0) * (stateG3_1=0) * (stateG3_2=1) * ((start=1))) -> FALSE);
// all these rules can be summarized as: only in state 000, start=1 is allowed:
assign sys_safe_err4 =  (reg_stateG3_0 | reg_stateG3_1 | reg_stateG3_2) & ~controllable_nstart;

// G( (hready=1) -> (   (hgrant0=1) <-> (X(hmaster0=0))  ) );
assign sys_safe_err5 =  ~( ~(reg_i_hready) | ( ~reg_controllable_nhgrant0 ^~ ( ~(controllable_hmaster0) ) ) );

// G( (hready=1) -> (   (hgrant1=1) <-> (X(hmaster0=1))  ) );
assign sys_safe_err6 =  ~( ~(reg_i_hready) | ( reg_controllable_hgrant1 ^~ ( controllable_hmaster0 ) ) );

// HMASTLOCK:
// G(  (hready=1) -> (locked=0 <-> X(hmastlock=0) ) );
assign sys_safe_err7 =  ~( ~(reg_i_hready) | (~reg_controllable_locked ^~ ~controllable_hmastlock) );

// Master 0:
// G( X(start=0) -> ( ((hmaster0=0)) <-> (X(hmaster0=0)) ) );
assign sys_safe_err8 =  ~( ~(controllable_nstart) | ( ( ~(reg_controllable_hmaster0) ) ^~ ( ~(controllable_hmaster0) )) );

// Master 1:
// G( X(start=0) -> ( ((hmaster0=1)) <-> (X(hmaster0=1)) ) );
assign sys_safe_err9 =  ~( ~(controllable_nstart) | ( ( reg_controllable_hmaster0 ) ^~ ( controllable_hmaster0 )) );

// Guarantee 6.2:
// G( ((X(start=0))) -> ( (hmastlock=1) <-> X(hmastlock=1)) );
assign sys_safe_err10 =  ~( ~(controllable_nstart) | ( reg_controllable_hmastlock ^~ controllable_hmastlock) );

// G( (decide=1  *  hlock0=1  *  X(hgrant0=1) )->X(locked=1));
assign sys_safe_err11 =  ~( ~(~reg_controllable_ndecide & reg_i_hlock0 & ~controllable_nhgrant0) | (controllable_locked) );

// G((decide=1  *  hlock0=0  *  X(hgrant0=1))->X(locked=0));
assign sys_safe_err12 =  ~( ~(~reg_controllable_ndecide & ~reg_i_hlock0 & ~controllable_nhgrant0) | (~controllable_locked) );

// G( (decide=1  *  hlock1=1  *  X(hgrant1=1) )->X(locked=1));
assign sys_safe_err13 =  ~( ~(~reg_controllable_ndecide & reg_i_hlock1 & controllable_hgrant1) | (controllable_locked) );

// G((decide=1  *  hlock1=0  *  X(hgrant1=1))->X(locked=0));
assign sys_safe_err14 =  ~( ~(~reg_controllable_ndecide & ~reg_i_hlock1 & controllable_hgrant1) | (~controllable_locked) );

// G( (decide=0) -> (  ((hgrant0=0)<->X(hgrant0=0))  ));
assign sys_safe_err15 =  ~( ~(reg_controllable_ndecide) | (reg_controllable_nhgrant0 ^~ controllable_nhgrant0) );

// G( (decide=0) -> (  ((hgrant1=0)<->X(hgrant1=0))  ));
assign sys_safe_err16 =  ~( ~(reg_controllable_ndecide) | (~reg_controllable_hgrant1 ^~ ~controllable_hgrant1) );

// G((decide=0)->(locked=0 <-> X(locked=0)));
assign sys_safe_err17 =  ~( ~(reg_controllable_ndecide) | (~reg_controllable_locked ^~ ~controllable_locked) );

// G(((stateG10_1=1) * (((hgrant1=1)) * (hbusreq1=0)))->FALSE);
assign sys_safe_err18 =  ~( ~(reg_stateG10_1 & (controllable_hgrant1 & ~i_hbusreq1)) | 0 );

// default master
// G((decide=1  *  hbusreq0=0  *  hbusreq1=0) -> X(hgrant0=1));
assign sys_safe_err19 =  ~( ~(~reg_controllable_ndecide & (~reg_i_hbusreq0 & ~reg_i_hbusreq1)) | (~controllable_nhgrant0) );

// collecting together the safety error bits:
assign sys_safe_err = sys_safe_err0 |
                      sys_safe_err1 |
                      sys_safe_err2 |
                      sys_safe_err3 |
                      sys_safe_err4 |
                      sys_safe_err5 |
                      sys_safe_err6 |
                      sys_safe_err7 |
                      sys_safe_err8 |
                      sys_safe_err9 |
                      sys_safe_err10 |
                      sys_safe_err11 |
                      sys_safe_err12 |
                      sys_safe_err13 |
                      sys_safe_err14 |
                      sys_safe_err15 |
                      sys_safe_err16 |
                      sys_safe_err17 |
                      sys_safe_err18 |
                      sys_safe_err19;

// =============================================================
//                          ENV_FAIRNESS:
// =============================================================
// Assumption 1: 
// G(F(stateA1=0));
assign env_fair0 =  ~reg_stateA1;

// Assumption 2:
// G(F(hready=1));
assign env_fair1 =  i_hready;


// =============================================================
//                          SYS_FAIRNESS:
// =============================================================
// Guarantee 2:
// G(F(stateG2=0));
assign sys_fair0 = ~reg_stateG2;

// Guarantee 3:
// G(F((stateG3_0=0)  *  (stateG3_1=0)  *  (stateG3_2=0)));
assign sys_fair1 =  (~reg_stateG3_0 & ~reg_stateG3_1 & ~reg_stateG3_2);

// G(F(((hmaster0=0))  |  hbusreq0=0));
assign sys_fair2 =  ( ~(controllable_hmaster0) ) | ~i_hbusreq0;

// G(F(((hmaster0=1))  |  hbusreq1=0));
assign sys_fair3 =  ( controllable_hmaster0 ) | ~i_hbusreq1;

assign fair_err = (fair_cnt >= 4'b1110);

// computing the error output bit:
assign o_err = ~env_safe_err & ~env_safe_err_happened & (sys_safe_err | fair_err);

initial
 begin
  reg_i_hready = 0;
  reg_i_hbusreq0 = 0;
  reg_i_hlock0 = 0;
  reg_i_hbusreq1 = 0;
  reg_i_hlock1 = 0;
  reg_controllable_hmaster0 = 0;
  reg_controllable_hmastlock = 0;
  reg_controllable_nstart = 0;
  reg_controllable_ndecide = 0;
  reg_controllable_locked = 0;
  reg_controllable_nhgrant0 = 0;
  reg_controllable_hgrant1 = 0;
  reg_controllable_busreq = 0;
  reg_stateA1 = 0;
  reg_stateG2 = 0;
  reg_stateG3_0 = 0;
  reg_stateG3_1 = 0;
  reg_stateG3_2 = 0;
  reg_stateG10_1 = 0;
  env_safe_err_happened = 0;
  next_env_fair = 0;
  fair_cnt = 0;
  next_sys_fair = 0;
 end


always @(posedge i_clk)
 begin
   // We remember if an environment error occurred:
   env_safe_err_happened = env_safe_err_happened | env_safe_err;

   // Updating the fairness counters: 
   if((next_sys_fair == 0) & sys_fair0)
    begin
      next_sys_fair = 1;
      next_env_fair = 0;
      fair_cnt = 0;
    end
   else if((next_sys_fair == 1) & sys_fair1)
    begin
      next_sys_fair = 2;
      next_env_fair = 0;
      fair_cnt = 0;
    end
   else if((next_sys_fair == 2) & sys_fair2)
    begin
      next_sys_fair = 3;
      next_env_fair = 0;
      fair_cnt = 0;
    end
   else if((next_sys_fair == 3) & sys_fair3)
    begin
      next_sys_fair = 0;
      next_env_fair = 0;
      fair_cnt = 0;
    end
   else if(~next_env_fair & env_fair0)
    begin
      next_env_fair = 1;
    end
   else if(next_env_fair & env_fair1)
    begin
      next_env_fair = 0;
      fair_cnt = fair_cnt + 1;
    end

   // Updating the automata: 
   // Automaton A1: 
   if(~reg_stateA1 & controllable_hmastlock & ~i_hburst0 & ~i_hburst1)
    begin
      reg_stateA1 = 1'b1;
    end
   else if(reg_stateA1 & ~controllable_busreq)
    begin
      reg_stateA1 = 1'b0;
    end

   // Automaton G2: 
   if(~reg_stateG2)
    begin
      if(controllable_hmastlock & ~controllable_nstart & ~i_hburst0 & ~i_hburst1)
       begin
         reg_stateG2 = 1'b1;
       end
    end
   else // if(reg_stateG2)
    begin
      if(~controllable_busreq)
       begin
         reg_stateG2 = 1'b0;
       end
    end

   // Automaton G3: 
   if(~reg_stateG3_0 & ~reg_stateG3_1 & ~reg_stateG3_2 & controllable_hmastlock & ~controllable_nstart &  ~i_hburst0 & i_hburst1 & ~i_hready)
    begin
      reg_stateG3_0 = 1'b1;
      reg_stateG3_1 = 1'b0;
      reg_stateG3_2 = 1'b0;
    end
   else if(~reg_stateG3_0 & ~reg_stateG3_1 & ~reg_stateG3_2 & controllable_hmastlock & ~controllable_nstart &  ~i_hburst0 & i_hburst1 & i_hready)
    begin
      reg_stateG3_0 = 1'b0;
      reg_stateG3_1 = 1'b1;
      reg_stateG3_2 = 1'b0;
    end
   else if(reg_stateG3_0 & ~reg_stateG3_1 & ~reg_stateG3_2 & i_hready)
    begin
      reg_stateG3_0 = 1'b0;
      reg_stateG3_1 = 1'b1;
      reg_stateG3_2 = 1'b0;
    end
   else if(~reg_stateG3_0 & reg_stateG3_1 & ~reg_stateG3_2 & i_hready)
    begin
      reg_stateG3_0 = 1'b1;
      reg_stateG3_1 = 1'b1;
      reg_stateG3_2 = 1'b0;
    end
   else if(reg_stateG3_0 & reg_stateG3_1 & ~reg_stateG3_2 & i_hready)
    begin
      reg_stateG3_0 = 1'b0;
      reg_stateG3_1 = 1'b0;
      reg_stateG3_2 = 1'b1;
    end
   else if(~reg_stateG3_0 & ~reg_stateG3_1 & reg_stateG3_2 & i_hready)
    begin
      reg_stateG3_0 = 1'b0;
      reg_stateG3_1 = 1'b0;
      reg_stateG3_2 = 1'b0;
    end

   // Automaton G10_1: 
   if(~reg_stateG10_1 & ~controllable_hgrant1 & ~i_hbusreq1)
    begin
      reg_stateG10_1 = 1'b1;
    end
   else if(reg_stateG10_1 & i_hbusreq1)
    begin
      reg_stateG10_1 = 1'b0;
    end

   // Latching the previous input:
   reg_i_hready =  i_hready;
   reg_i_hbusreq0 =  i_hbusreq0;
   reg_i_hlock0 =  i_hlock0;
   reg_i_hbusreq1 =  i_hbusreq1;
   reg_i_hlock1 =  i_hlock1;
   reg_controllable_hmaster0 =  controllable_hmaster0;
   reg_controllable_hmastlock =  controllable_hmastlock;
   reg_controllable_nstart =  controllable_nstart;
   reg_controllable_ndecide =  controllable_ndecide;
   reg_controllable_locked =  controllable_locked;
   reg_controllable_nhgrant0 =  controllable_nhgrant0;
   reg_controllable_hgrant1 =  controllable_hgrant1;
   reg_controllable_busreq =  controllable_busreq;

 end
endmodule

-------------------------------
