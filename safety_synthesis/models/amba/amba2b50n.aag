aag 481 15 33 1 433
2
4
6
8
10
12
14
16
18
20
22
24
26
28
30
32 1
34 525
36 609
38 655
40 14
42 669
44 693
46 28
48 713
50 2
52 24
54 8
56 4
58 727
60 757
62 779
64 791
66 30
68 815
70 6
72 22
74 919
76 925
78 931
80 937
82 943
84 949
86 109
88 18
90 26
92 20
94 963
96 16
450
98 18 3
100 22 5
102 101 99
104 87 32
106 105 32
108 107 102
110 25 2
112 24 3
114 113 111
116 115 17
118 25 4
120 24 5
122 121 119
124 123 16
126 125 117
128 91 32
130 90 32
132 129 32
134 133 9
136 135 126
138 61 32
140 60 32
142 139 32
144 140 9
146 145 136
148 37 32
150 36 32
152 149 32
154 45 32
156 44 32
158 155 32
160 159 153
162 49 32
164 48 32
166 163 32
168 167 160
170 169 9
172 171 146
174 67 32
176 66 32
178 175 32
180 176 17
182 179 16
184 183 181
186 185 130
188 187 172
190 93 32
192 92 32
194 191 32
196 195 16
198 192 17
200 199 197
202 201 130
204 203 188
206 41 32
208 40 32
210 207 32
212 208 7
214 211 6
216 215 213
218 217 130
220 219 204
222 97 32
224 96 32
226 223 32
228 224 17
230 227 16
232 231 229
234 233 8
236 235 220
238 236 235
240 71 32
242 70 32
244 241 32
246 245 6
248 242 7
250 249 247
252 251 8
254 253 238
256 47 32
258 46 32
260 257 32
262 89 32
264 88 32
266 263 32
268 264 261
270 268 31
272 270 15
274 273 254
276 267 261
278 276 31
280 278 14
282 281 274
284 73 32
286 72 32
288 285 32
290 286 261
292 290 20
294 292 15
296 295 282
298 289 261
300 298 20
302 300 14
304 303 296
306 179 30
308 176 31
310 309 307
312 311 258
314 313 304
316 192 21
318 195 20
320 319 317
322 321 258
324 323 314
326 208 15
328 211 14
330 329 327
332 331 258
334 333 324
336 63 32
338 62 32
340 337 32
342 20 5
344 342 338
346 345 334
348 51 32
350 349 32
352 57 32
354 353 32
356 355 351
358 356 261
360 358 30
362 361 346
364 85 32
366 84 32
368 365 32
370 83 32
372 82 32
374 371 32
376 81 32
378 80 32
380 377 32
382 79 32
384 78 32
386 383 32
388 77 32
390 76 32
392 389 32
394 75 32
396 74 32
398 395 32
400 393 387
402 400 381
404 402 375
406 405 374
408 406 403
410 409 369
412 411 368
414 412 408
416 392 384
418 417 401
420 401 378
422 421 403
424 403 375
426 402 372
428 427 425
430 408 369
432 409 366
434 433 431
436 397 392
438 436 418
440 438 422
442 440 428
444 442 434
446 445 415
448 446 362
450 449 108
452 35 32
454 34 32
456 453 32
458 457 140
460 59 32
462 58 32
464 461 32
466 465 169
468 467 459
470 95 32
472 94 32
474 471 32
476 16 2
478 476 475
480 479 468
482 43 32
484 42 32
486 483 32
488 17 4
490 488 487
492 491 480
494 457 143
496 465 168
498 497 495
500 477 475
502 501 498
504 489 487
506 505 502
508 507 493
510 509 493
512 507 459
514 506 454
516 515 513
518 517 493
520 518 511
522 510 454
524 523 521
526 168 6
528 526 9
530 528 13
532 530 10
534 532 27
536 532 26
538 159 150
540 538 167
542 540 26
544 156 153
546 544 167
548 546 26
550 156 150
552 550 167
554 552 26
556 164 160
558 556 26
560 536 535
562 561 535
564 537 535
566 564 542
568 567 562
570 564 543
572 570 548
574 573 568
576 570 549
578 576 554
580 579 574
582 576 555
584 582 558
586 585 580
588 559 150
590 588 555
592 590 549
594 593 549
596 595 543
598 596 537
600 598 535
602 601 535
604 603 587
606 586 150
608 607 605
610 65 32
612 64 32
614 611 32
616 69 32
618 68 32
620 617 32
622 618 615
624 39 32
626 38 32
628 625 32
630 629 27
632 631 623
634 506 493
636 634 632
638 637 510
640 634 633
642 641 638
644 633 631
646 644 506
648 646 493
650 648 643
652 642 626
654 653 651
656 507 491
658 506 484
660 659 657
662 661 493
664 662 511
666 510 484
668 667 665
670 559 156
672 670 555
674 672 549
676 675 549
678 677 543
680 679 543
682 681 537
684 683 537
686 685 535
688 686 587
690 586 156
692 691 689
694 559 164
696 694 555
698 697 555
700 699 549
702 700 543
704 702 537
706 704 535
708 706 587
710 586 164
712 711 709
714 507 467
716 506 462
718 717 715
720 719 493
722 720 511
724 510 462
726 725 723
728 9 6
730 728 13
732 730 11
734 732 143
736 140 25
738 737 735
740 733 140
742 741 733
744 140 24
746 743 143
748 744 140
750 749 747
752 751 739
754 738 140
756 755 753
758 341 21
760 758 5
762 338 4
764 762 761
766 765 761
768 763 338
770 768 761
772 771 761
774 773 767
776 766 338
778 777 775
780 633 623
782 780 506
784 782 493
786 784 643
788 642 612
790 789 787
792 621 6
794 792 13
796 794 11
798 618 25
800 798 797
802 801 797
804 799 618
806 804 797
808 807 797
810 809 803
812 802 618
814 813 811
816 632 399
818 633 396
820 819 817
822 821 506
824 822 493
826 396 393
828 397 390
830 829 827
832 831 632
834 633 390
836 835 833
838 837 506
840 838 493
842 396 390
844 842 387
846 843 384
848 847 845
850 849 632
852 633 384
854 853 851
856 855 506
858 856 493
860 842 384
862 860 381
864 861 378
866 865 863
868 867 632
870 633 378
872 871 869
874 873 506
876 874 493
878 860 378
880 878 375
882 879 372
884 883 881
886 885 632
888 633 372
890 889 887
892 891 506
894 892 493
896 878 372
898 896 369
900 897 366
902 901 899
904 903 632
906 633 366
908 907 905
910 909 506
912 910 493
914 824 639
916 638 396
918 917 915
920 840 639
922 638 390
924 923 921
926 858 639
928 638 384
930 929 927
932 876 639
934 638 378
936 935 933
938 894 639
940 638 372
942 941 939
944 912 639
946 638 366
948 947 945
950 507 479
952 506 472
954 953 951
956 955 493
958 956 511
960 510 472
962 961 959
i0 i_hbusreq0
i1 i_hbusreq1
i2 controllable_hmastlock
i3 controllable_nstart
i4 i_hburst1
i5 i_hburst0
i6 controllable_locked
i7 controllable_hmaster0
i8 i_hlock0
i9 controllable_hgrant1
i10 i_hlock1
i11 controllable_busreq
i12 i_hready
i13 controllable_ndecide
i14 controllable_nhgrant0
l0 n33
l1 sys_fair0done_out
l2 reg_stateG3_0_out
l3 env_fair1done_out
l4 reg_controllable_locked_out
l5 sys_fair3done_out
l6 reg_stateG3_1_out
l7 reg_controllable_ndecide_out
l8 reg_stateG3_2_out
l9 reg_i_hbusreq0_out
l10 reg_controllable_busreq_out
l11 reg_controllable_nstart_out
l12 reg_i_hbusreq1_out
l13 sys_fair1done_out
l14 reg_stateG2_out
l15 reg_stateG10_1_out
l16 env_fair0done_out
l17 reg_controllable_nhgrant0_out
l18 reg_stateA1_out
l19 reg_controllable_hmastlock_out
l20 reg_i_hlock1_out
l21 fair_cnt<0>_out
l22 fair_cnt<1>_out
l23 fair_cnt<2>_out
l24 fair_cnt<3>_out
l25 fair_cnt<4>_out
l26 fair_cnt<5>_out
l27 env_safe_err_happened_out
l28 reg_i_hlock0_out
l29 reg_i_hready_out
l30 reg_controllable_hgrant1_out
l31 sys_fair2done_out
l32 reg_controllable_hmaster0_out
o0 o_err
c
amba_2_new_50
This file was written by ABC on Tue May  5 16:50:17 2015
For information about AIGER format, refer to http://fmv.jku.at/aiger
-------------------------------
This AIGER file has been created by the following sequence of commands:
> vl2mv amba2b50.v   ---gives--> amba2b50.mv
> abc -c "read_blif_mv amba2b50.mv; write_aiger -s amba2b50n.aig"   ---gives--> amba2b50n.aig
> aigtoaig amba2b50n.aig amba2b50n.aag   ---gives--> amba2b50n.aag (this file)
Content of amba2b50.v:
module amba_2_new_50(
        o_err,
        i_clk,
        i_hready,
        i_hbusreq0,
        i_hlock0,
        i_hbusreq1,
        i_hlock1,
        i_hburst0,
        i_hburst1,
        controllable_hmaster0,
        controllable_hmastlock,
        controllable_nstart,
        controllable_ndecide,
        controllable_locked,
        controllable_nhgrant0,
        controllable_hgrant1,
        controllable_busreq);

input i_clk;
input i_hready;
input i_hbusreq0;
input i_hlock0;
input i_hbusreq1;
input i_hlock1;
input i_hburst0;
input i_hburst1;
input controllable_hmaster0;
input controllable_hmastlock;
input controllable_nstart;
input controllable_ndecide;
input controllable_locked;
input controllable_nhgrant0;
input controllable_hgrant1;
input controllable_busreq;
output o_err;

reg reg_i_hready;
reg reg_i_hbusreq0;
reg reg_i_hlock0;
reg reg_i_hbusreq1;
reg reg_i_hlock1;
reg reg_controllable_hmaster0;
reg reg_controllable_hmastlock;
reg reg_controllable_nstart;
reg reg_controllable_ndecide;
reg reg_controllable_locked;
reg reg_controllable_nhgrant0;
reg reg_controllable_hgrant1;
reg reg_controllable_busreq;
reg reg_stateA1;
reg reg_stateG2;
reg reg_stateG3_0;
reg reg_stateG3_1;
reg reg_stateG3_2;
reg reg_stateG10_1;
reg env_safe_err_happened;
reg env_fair0done;
reg env_fair1done;
reg sys_fair0done;
reg sys_fair1done;
reg sys_fair2done;
reg sys_fair3done;
reg [5:0] fair_cnt;

wire env_safe_err0;
wire env_safe_err1;
wire env_safe_err;

wire sys_safe_err0;
wire sys_safe_err1;
wire sys_safe_err2;
wire sys_safe_err3;
wire sys_safe_err4;
wire sys_safe_err5;
wire sys_safe_err6;
wire sys_safe_err7;
wire sys_safe_err8;
wire sys_safe_err9;
wire sys_safe_err10;
wire sys_safe_err11;
wire sys_safe_err12;
wire sys_safe_err13;
wire sys_safe_err14;
wire sys_safe_err15;
wire sys_safe_err16;
wire sys_safe_err17;
wire sys_safe_err18;
wire sys_safe_err19;
wire sys_safe_err;

wire env_fair0;
wire env_fair1;

wire sys_fair0;
wire sys_fair1;
wire sys_fair2;
wire sys_fair3;
wire progress_in_sys_fair;
wire all_env_fair_fulfilled;
wire all_sys_fair_fulfilled;
wire fair_err;
wire o_err;

// =============================================================
//                        ENV_TRANSITION:
// =============================================================
// Assumption 3:
// G( hlock0=1 -> hbusreq0=1 );
assign env_safe_err0 =  ~(~ i_hlock0 | i_hbusreq0);

// Assumption 3:
// G( hlock1=1 -> hbusreq1=1 );
assign env_safe_err1 =  ~(~ i_hlock1 | i_hbusreq1);

// collecting together the safety error bits:
assign env_safe_err = env_safe_err0 |
                      env_safe_err1;

// =============================================================
//                        SYS_TRANSITION:
// =============================================================
// G((hmaster0=0) -> (hbusreq0=0 <-> busreq=0));
assign sys_safe_err0 =  ~( ~( ~(controllable_hmaster0) )|(~i_hbusreq0 ^~ (~controllable_busreq)));

// G((hmaster0=1) -> (hbusreq1=0 <-> busreq=0));
assign sys_safe_err1 =  ~( ~( controllable_hmaster0 )|(~i_hbusreq1 ^~ (~controllable_busreq)));

// Guarantee 1:
// G((hready=0) -> X(start=0));
assign sys_safe_err2 =  ~( reg_i_hready | controllable_nstart );

// G(((stateG2=1) * (start=1)) -> FALSE;
assign sys_safe_err3 =  ~( ~(reg_stateG2 & ~controllable_nstart) | 0 );

// G(((stateG3_0=1) * (stateG3_1=0) * (stateG3_2=0) * ((start=1))) -> FALSE);
// G(((stateG3_0=0) * (stateG3_1=1) * (stateG3_2=0) * ((start=1))) -> FALSE);
// G(((stateG3_0=1) * (stateG3_1=1) * (stateG3_2=0) * ((start=1))) -> FALSE);
// G(((stateG3_0=0) * (stateG3_1=0) * (stateG3_2=1) * ((start=1))) -> FALSE);
// all these rules can be summarized as: only in state 000, start=1 is allowed:
assign sys_safe_err4 =  (reg_stateG3_0 | reg_stateG3_1 | reg_stateG3_2) & ~controllable_nstart;

// G( (hready=1) -> (   (hgrant0=1) <-> (X(hmaster0=0))  ) );
assign sys_safe_err5 =  ~( ~(reg_i_hready) | ( ~reg_controllable_nhgrant0 ^~ ( ~(controllable_hmaster0) ) ) );

// G( (hready=1) -> (   (hgrant1=1) <-> (X(hmaster0=1))  ) );
assign sys_safe_err6 =  ~( ~(reg_i_hready) | ( reg_controllable_hgrant1 ^~ ( controllable_hmaster0 ) ) );

// HMASTLOCK:
// G(  (hready=1) -> (locked=0 <-> X(hmastlock=0) ) );
assign sys_safe_err7 =  ~( ~(reg_i_hready) | (~reg_controllable_locked ^~ ~controllable_hmastlock) );

// Master 0:
// G( X(start=0) -> ( ((hmaster0=0)) <-> (X(hmaster0=0)) ) );
assign sys_safe_err8 =  ~( ~(controllable_nstart) | ( ( ~(reg_controllable_hmaster0) ) ^~ ( ~(controllable_hmaster0) )) );

// Master 1:
// G( X(start=0) -> ( ((hmaster0=1)) <-> (X(hmaster0=1)) ) );
assign sys_safe_err9 =  ~( ~(controllable_nstart) | ( ( reg_controllable_hmaster0 ) ^~ ( controllable_hmaster0 )) );

// Guarantee 6.2:
// G( ((X(start=0))) -> ( (hmastlock=1) <-> X(hmastlock=1)) );
assign sys_safe_err10 =  ~( ~(controllable_nstart) | ( reg_controllable_hmastlock ^~ controllable_hmastlock) );

// G( (decide=1  *  hlock0=1  *  X(hgrant0=1) )->X(locked=1));
assign sys_safe_err11 =  ~( ~(~reg_controllable_ndecide & reg_i_hlock0 & ~controllable_nhgrant0) | (controllable_locked) );

// G((decide=1  *  hlock0=0  *  X(hgrant0=1))->X(locked=0));
assign sys_safe_err12 =  ~( ~(~reg_controllable_ndecide & ~reg_i_hlock0 & ~controllable_nhgrant0) | (~controllable_locked) );

// G( (decide=1  *  hlock1=1  *  X(hgrant1=1) )->X(locked=1));
assign sys_safe_err13 =  ~( ~(~reg_controllable_ndecide & reg_i_hlock1 & controllable_hgrant1) | (controllable_locked) );

// G((decide=1  *  hlock1=0  *  X(hgrant1=1))->X(locked=0));
assign sys_safe_err14 =  ~( ~(~reg_controllable_ndecide & ~reg_i_hlock1 & controllable_hgrant1) | (~controllable_locked) );

// G( (decide=0) -> (  ((hgrant0=0)<->X(hgrant0=0))  ));
assign sys_safe_err15 =  ~( ~(reg_controllable_ndecide) | (reg_controllable_nhgrant0 ^~ controllable_nhgrant0) );

// G( (decide=0) -> (  ((hgrant1=0)<->X(hgrant1=0))  ));
assign sys_safe_err16 =  ~( ~(reg_controllable_ndecide) | (~reg_controllable_hgrant1 ^~ ~controllable_hgrant1) );

// G((decide=0)->(locked=0 <-> X(locked=0)));
assign sys_safe_err17 =  ~( ~(reg_controllable_ndecide) | (~reg_controllable_locked ^~ ~controllable_locked) );

// G(((stateG10_1=1) * (((hgrant1=1)) * (hbusreq1=0)))->FALSE);
assign sys_safe_err18 =  ~( ~(reg_stateG10_1 & (controllable_hgrant1 & ~i_hbusreq1)) | 0 );

// default master
// G((decide=1  *  hbusreq0=0  *  hbusreq1=0) -> X(hgrant0=1));
assign sys_safe_err19 =  ~( ~(~reg_controllable_ndecide & (~reg_i_hbusreq0 & ~reg_i_hbusreq1)) | (~controllable_nhgrant0) );

// collecting together the safety error bits:
assign sys_safe_err = sys_safe_err0 |
                      sys_safe_err1 |
                      sys_safe_err2 |
                      sys_safe_err3 |
                      sys_safe_err4 |
                      sys_safe_err5 |
                      sys_safe_err6 |
                      sys_safe_err7 |
                      sys_safe_err8 |
                      sys_safe_err9 |
                      sys_safe_err10 |
                      sys_safe_err11 |
                      sys_safe_err12 |
                      sys_safe_err13 |
                      sys_safe_err14 |
                      sys_safe_err15 |
                      sys_safe_err16 |
                      sys_safe_err17 |
                      sys_safe_err18 |
                      sys_safe_err19;

// =============================================================
//                          ENV_FAIRNESS:
// =============================================================
// Assumption 1: 
// G(F(stateA1=0));
assign env_fair0 =  ~reg_stateA1;

// Assumption 2:
// G(F(hready=1));
assign env_fair1 =  i_hready;

assign all_env_fair_fulfilled = (env_fair0done | env_fair0) &
                                (env_fair1done | env_fair1);

// =============================================================
//                          SYS_FAIRNESS:
// =============================================================
// Guarantee 2:
// G(F(stateG2=0));
assign sys_fair0 = ~reg_stateG2;

// Guarantee 3:
// G(F((stateG3_0=0)  *  (stateG3_1=0)  *  (stateG3_2=0)));
assign sys_fair1 =  (~reg_stateG3_0 & ~reg_stateG3_1 & ~reg_stateG3_2);

// G(F(((hmaster0=0))  |  hbusreq0=0));
assign sys_fair2 =  ( ~(controllable_hmaster0) ) | ~i_hbusreq0;

// G(F(((hmaster0=1))  |  hbusreq1=0));
assign sys_fair3 =  ( controllable_hmaster0 ) | ~i_hbusreq1;

assign all_sys_fair_fulfilled = (sys_fair0done | sys_fair0) &
                                (sys_fair1done | sys_fair1) &
                                (sys_fair2done | sys_fair2) &
                                (sys_fair3done | sys_fair3);
assign progress_in_sys_fair = (~sys_fair0done & sys_fair0) |
                                (~sys_fair1done & sys_fair1) |
                                (~sys_fair2done & sys_fair2) |
                                (~sys_fair3done & sys_fair3);
assign fair_err = (fair_cnt >= 6'b110010);

// computing the error output bit:
assign o_err = ~env_safe_err & ~env_safe_err_happened & (sys_safe_err | fair_err);

initial
 begin
  reg_i_hready = 0;
  reg_i_hbusreq0 = 0;
  reg_i_hlock0 = 0;
  reg_i_hbusreq1 = 0;
  reg_i_hlock1 = 0;
  reg_controllable_hmaster0 = 0;
  reg_controllable_hmastlock = 0;
  reg_controllable_nstart = 0;
  reg_controllable_ndecide = 0;
  reg_controllable_locked = 0;
  reg_controllable_nhgrant0 = 0;
  reg_controllable_hgrant1 = 0;
  reg_controllable_busreq = 0;
  reg_stateA1 = 0;
  reg_stateG2 = 0;
  reg_stateG3_0 = 0;
  reg_stateG3_1 = 0;
  reg_stateG3_2 = 0;
  reg_stateG10_1 = 0;
  env_safe_err_happened = 0;
  env_fair0done = 0;
  env_fair1done = 0;
  sys_fair0done = 0;
  sys_fair1done = 0;
  sys_fair2done = 0;
  sys_fair3done = 0;
  fair_cnt = 0;
 end


always @(posedge i_clk)
 begin
   // We remember if an environment error occurred:
   env_safe_err_happened = env_safe_err_happened | env_safe_err;

   // Updating the fairness counters: 
   if(all_sys_fair_fulfilled)
    begin
      env_fair0done = 0;
      env_fair1done = 0;
      sys_fair0done = 0;
      sys_fair1done = 0;
      sys_fair2done = 0;
      sys_fair3done = 0;
      fair_cnt = 0;
    end
   else
    begin
      if(progress_in_sys_fair)
       begin
         env_fair0done = 0;
         env_fair1done = 0;
         fair_cnt = 0;
         sys_fair0done = sys_fair0done | sys_fair0;
         sys_fair1done = sys_fair1done | sys_fair1;
         sys_fair2done = sys_fair2done | sys_fair2;
         sys_fair3done = sys_fair3done | sys_fair3;
       end
      else
       begin
         if(all_env_fair_fulfilled)
          begin
            env_fair0done = 0;
            env_fair1done = 0;
            fair_cnt = fair_cnt + 1;
          end
         else
          begin
            env_fair0done = env_fair0done | env_fair0;
            env_fair1done = env_fair1done | env_fair1;
          end
       end
    end

   // Updating the automata: 
   // Automaton A1: 
   if(~reg_stateA1 & controllable_hmastlock & ~i_hburst0 & ~i_hburst1)
    begin
      reg_stateA1 = 1'b1;
    end
   else if(reg_stateA1 & ~controllable_busreq)
    begin
      reg_stateA1 = 1'b0;
    end

   // Automaton G2: 
   if(~reg_stateG2)
    begin
      if(controllable_hmastlock & ~controllable_nstart & ~i_hburst0 & ~i_hburst1)
       begin
         reg_stateG2 = 1'b1;
       end
    end
   else // if(reg_stateG2)
    begin
      if(~controllable_busreq)
       begin
         reg_stateG2 = 1'b0;
       end
    end

   // Automaton G3: 
   if(~reg_stateG3_0 & ~reg_stateG3_1 & ~reg_stateG3_2 & controllable_hmastlock & ~controllable_nstart &  ~i_hburst0 & i_hburst1 & ~i_hready)
    begin
      reg_stateG3_0 = 1'b1;
      reg_stateG3_1 = 1'b0;
      reg_stateG3_2 = 1'b0;
    end
   else if(~reg_stateG3_0 & ~reg_stateG3_1 & ~reg_stateG3_2 & controllable_hmastlock & ~controllable_nstart &  ~i_hburst0 & i_hburst1 & i_hready)
    begin
      reg_stateG3_0 = 1'b0;
      reg_stateG3_1 = 1'b1;
      reg_stateG3_2 = 1'b0;
    end
   else if(reg_stateG3_0 & ~reg_stateG3_1 & ~reg_stateG3_2 & i_hready)
    begin
      reg_stateG3_0 = 1'b0;
      reg_stateG3_1 = 1'b1;
      reg_stateG3_2 = 1'b0;
    end
   else if(~reg_stateG3_0 & reg_stateG3_1 & ~reg_stateG3_2 & i_hready)
    begin
      reg_stateG3_0 = 1'b1;
      reg_stateG3_1 = 1'b1;
      reg_stateG3_2 = 1'b0;
    end
   else if(reg_stateG3_0 & reg_stateG3_1 & ~reg_stateG3_2 & i_hready)
    begin
      reg_stateG3_0 = 1'b0;
      reg_stateG3_1 = 1'b0;
      reg_stateG3_2 = 1'b1;
    end
   else if(~reg_stateG3_0 & ~reg_stateG3_1 & reg_stateG3_2 & i_hready)
    begin
      reg_stateG3_0 = 1'b0;
      reg_stateG3_1 = 1'b0;
      reg_stateG3_2 = 1'b0;
    end

   // Automaton G10_1: 
   if(~reg_stateG10_1 & ~controllable_hgrant1 & ~i_hbusreq1)
    begin
      reg_stateG10_1 = 1'b1;
    end
   else if(reg_stateG10_1 & i_hbusreq1)
    begin
      reg_stateG10_1 = 1'b0;
    end

   // Latching the previous input:
   reg_i_hready =  i_hready;
   reg_i_hbusreq0 =  i_hbusreq0;
   reg_i_hlock0 =  i_hlock0;
   reg_i_hbusreq1 =  i_hbusreq1;
   reg_i_hlock1 =  i_hlock1;
   reg_controllable_hmaster0 =  controllable_hmaster0;
   reg_controllable_hmastlock =  controllable_hmastlock;
   reg_controllable_nstart =  controllable_nstart;
   reg_controllable_ndecide =  controllable_ndecide;
   reg_controllable_locked =  controllable_locked;
   reg_controllable_nhgrant0 =  controllable_nhgrant0;
   reg_controllable_hgrant1 =  controllable_hgrant1;
   reg_controllable_busreq =  controllable_busreq;

 end
endmodule

-------------------------------
#!SYNTCOMP
STATUS : realizable
SOLVED_BY : 3/3 [2015-pre-classification]
SOLVED_IN : 0.337812 [2015-pre-classification]
#.
