aag 435 15 33 1 387
2
4
6
8
10
12
14
16
18
20
22
24
26
28
30
32 1
34 486
36 571
38 613
40 14
42 614
44 639
46 28
48 659
50 2
52 24
54 8
56 4
58 660
60 691
62 713
64 723
66 30
68 747
70 6
72 22
74 839
76 845
78 851
80 857
82 863
84 869
86 109
88 18
90 26
92 20
94 870
96 16
450
98 18 3
100 22 5
102 101 99
104 87 32
106 105 32
108 107 102
110 25 2
112 24 3
114 113 111
116 115 17
118 25 4
120 24 5
122 121 119
124 123 16
126 125 117
128 91 32
130 90 32
132 129 32
134 133 9
136 135 126
138 61 32
140 60 32
142 139 32
144 140 9
146 145 136
148 37 32
150 36 32
152 149 32
154 45 32
156 44 32
158 155 32
160 159 153
162 49 32
164 48 32
166 163 32
168 167 160
170 169 9
172 171 146
174 67 32
176 66 32
178 175 32
180 176 17
182 179 16
184 183 181
186 185 130
188 187 172
190 93 32
192 92 32
194 191 32
196 195 16
198 192 17
200 199 197
202 201 130
204 203 188
206 41 32
208 40 32
210 207 32
212 208 7
214 211 6
216 215 213
218 217 130
220 219 204
222 97 32
224 96 32
226 223 32
228 224 17
230 227 16
232 231 229
234 233 8
236 235 220
238 236 235
240 71 32
242 70 32
244 241 32
246 245 6
248 242 7
250 249 247
252 251 8
254 253 238
256 47 32
258 46 32
260 257 32
262 89 32
264 88 32
266 263 32
268 264 261
270 268 31
272 270 15
274 273 254
276 267 261
278 276 31
280 278 14
282 281 274
284 73 32
286 72 32
288 285 32
290 286 261
292 290 20
294 292 15
296 295 282
298 289 261
300 298 20
302 300 14
304 303 296
306 179 30
308 176 31
310 309 307
312 311 258
314 313 304
316 192 21
318 195 20
320 319 317
322 321 258
324 323 314
326 208 15
328 211 14
330 329 327
332 331 258
334 333 324
336 63 32
338 62 32
340 337 32
342 20 5
344 342 338
346 345 334
348 51 32
350 349 32
352 57 32
354 353 32
356 355 351
358 356 261
360 358 30
362 361 346
364 85 32
366 84 32
368 365 32
370 83 32
372 82 32
374 371 32
376 81 32
378 80 32
380 377 32
382 79 32
384 78 32
386 383 32
388 77 32
390 76 32
392 389 32
394 75 32
396 74 32
398 395 32
400 393 387
402 400 381
404 402 375
406 405 374
408 406 403
410 409 369
412 411 368
414 412 408
416 392 384
418 417 401
420 401 378
422 421 403
424 403 375
426 402 372
428 427 425
430 408 369
432 409 366
434 433 431
436 397 392
438 436 418
440 438 422
442 440 428
444 442 434
446 445 415
448 446 362
450 449 108
452 35 32
454 453 32
456 455 140
458 59 32
460 459 32
462 461 169
464 463 457
466 95 32
468 467 32
470 16 2
472 470 469
474 473 464
476 43 32
478 477 32
480 17 4
482 480 479
484 483 474
486 485 457
488 168 6
490 488 9
492 490 13
494 492 10
496 494 27
498 494 26
500 159 150
502 500 167
504 502 26
506 156 153
508 506 167
510 508 26
512 156 150
514 512 167
516 514 26
518 164 160
520 518 26
522 498 497
524 523 497
526 499 497
528 526 504
530 529 524
532 526 505
534 532 510
536 535 530
538 532 511
540 538 516
542 541 536
544 538 517
546 544 520
548 547 542
550 521 150
552 550 517
554 552 511
556 555 511
558 557 505
560 558 499
562 560 497
564 563 497
566 565 549
568 548 150
570 569 567
572 65 32
574 64 32
576 573 32
578 69 32
580 68 32
582 579 32
584 580 577
586 39 32
588 38 32
590 587 32
592 591 27
594 593 585
596 594 485
598 597 485
600 595 485
602 601 598
604 595 593
606 604 485
608 606 603
610 602 588
612 611 609
614 485 483
616 521 156
618 616 517
620 618 511
622 621 511
624 623 505
626 625 505
628 627 499
630 629 499
632 631 497
634 632 549
636 548 156
638 637 635
640 521 164
642 640 517
644 643 517
646 645 511
648 646 505
650 648 499
652 650 497
654 652 549
656 548 164
658 657 655
660 485 463
662 9 6
664 662 13
666 664 11
668 666 143
670 140 25
672 671 669
674 667 140
676 675 667
678 140 24
680 677 143
682 678 140
684 683 681
686 685 673
688 672 140
690 689 687
692 341 21
694 692 5
696 338 4
698 696 695
700 699 695
702 697 338
704 702 695
706 705 695
708 707 701
710 700 338
712 711 709
714 595 585
716 714 485
718 716 603
720 602 574
722 721 719
724 583 6
726 724 13
728 726 11
730 580 25
732 730 729
734 733 729
736 731 580
738 736 729
740 739 729
742 741 735
744 734 580
746 745 743
748 594 399
750 595 396
752 751 749
754 753 485
756 396 393
758 397 390
760 759 757
762 761 594
764 595 390
766 765 763
768 767 485
770 396 390
772 770 387
774 771 384
776 775 773
778 777 594
780 595 384
782 781 779
784 783 485
786 770 384
788 786 381
790 787 378
792 791 789
794 793 594
796 595 378
798 797 795
800 799 485
802 786 378
804 802 375
806 803 372
808 807 805
810 809 594
812 595 372
814 813 811
816 815 485
818 802 372
820 818 369
822 819 366
824 823 821
826 825 594
828 595 366
830 829 827
832 831 485
834 754 599
836 598 396
838 837 835
840 768 599
842 598 390
844 843 841
846 784 599
848 598 384
850 849 847
852 800 599
854 598 378
856 855 853
858 816 599
860 598 372
862 861 859
864 832 599
866 598 366
868 867 865
870 485 473
i0 i_hbusreq0
i1 i_hbusreq1
i2 controllable_hmastlock
i3 controllable_nstart
i4 i_hburst1
i5 i_hburst0
i6 controllable_locked
i7 controllable_hmaster0
i8 i_hlock0
i9 controllable_hgrant1
i10 i_hlock1
i11 controllable_busreq
i12 i_hready
i13 controllable_ndecide
i14 controllable_nhgrant0
l0 n33
l1 sys_fair0done_out
l2 reg_stateG3_0_out
l3 env_fair1done_out
l4 reg_controllable_locked_out
l5 sys_fair3done_out
l6 reg_stateG3_1_out
l7 reg_controllable_ndecide_out
l8 reg_stateG3_2_out
l9 reg_i_hbusreq0_out
l10 reg_controllable_busreq_out
l11 reg_controllable_nstart_out
l12 reg_i_hbusreq1_out
l13 sys_fair1done_out
l14 reg_stateG2_out
l15 reg_stateG10_1_out
l16 env_fair0done_out
l17 reg_controllable_nhgrant0_out
l18 reg_stateA1_out
l19 reg_controllable_hmastlock_out
l20 reg_i_hlock1_out
l21 fair_cnt<0>_out
l22 fair_cnt<1>_out
l23 fair_cnt<2>_out
l24 fair_cnt<3>_out
l25 fair_cnt<4>_out
l26 fair_cnt<5>_out
l27 env_safe_err_happened_out
l28 reg_i_hlock0_out
l29 reg_i_hready_out
l30 reg_controllable_hgrant1_out
l31 sys_fair2done_out
l32 reg_controllable_hmaster0_out
o0 o_err
c
amba_2_new_50
This file was written by ABC on Tue May  5 16:50:56 2015
For information about AIGER format, refer to http://fmv.jku.at/aiger
-------------------------------
This AIGER file has been created by the following sequence of commands:
> vl2mv amba2f50.v   ---gives--> amba2f50.mv
> abc -c "read_blif_mv amba2f50.mv; write_aiger -s amba2f50n.aig"   ---gives--> amba2f50n.aig
> aigtoaig amba2f50n.aig amba2f50n.aag   ---gives--> amba2f50n.aag (this file)
Content of amba2f50.v:
module amba_2_new_50(
        o_err,
        i_clk,
        i_hready,
        i_hbusreq0,
        i_hlock0,
        i_hbusreq1,
        i_hlock1,
        i_hburst0,
        i_hburst1,
        controllable_hmaster0,
        controllable_hmastlock,
        controllable_nstart,
        controllable_ndecide,
        controllable_locked,
        controllable_nhgrant0,
        controllable_hgrant1,
        controllable_busreq);

input i_clk;
input i_hready;
input i_hbusreq0;
input i_hlock0;
input i_hbusreq1;
input i_hlock1;
input i_hburst0;
input i_hburst1;
input controllable_hmaster0;
input controllable_hmastlock;
input controllable_nstart;
input controllable_ndecide;
input controllable_locked;
input controllable_nhgrant0;
input controllable_hgrant1;
input controllable_busreq;
output o_err;

reg reg_i_hready;
reg reg_i_hbusreq0;
reg reg_i_hlock0;
reg reg_i_hbusreq1;
reg reg_i_hlock1;
reg reg_controllable_hmaster0;
reg reg_controllable_hmastlock;
reg reg_controllable_nstart;
reg reg_controllable_ndecide;
reg reg_controllable_locked;
reg reg_controllable_nhgrant0;
reg reg_controllable_hgrant1;
reg reg_controllable_busreq;
reg reg_stateA1;
reg reg_stateG2;
reg reg_stateG3_0;
reg reg_stateG3_1;
reg reg_stateG3_2;
reg reg_stateG10_1;
reg env_safe_err_happened;
reg env_fair0done;
reg env_fair1done;
reg sys_fair0done;
reg sys_fair1done;
reg sys_fair2done;
reg sys_fair3done;
reg [5:0] fair_cnt;

wire env_safe_err0;
wire env_safe_err1;
wire env_safe_err;

wire sys_safe_err0;
wire sys_safe_err1;
wire sys_safe_err2;
wire sys_safe_err3;
wire sys_safe_err4;
wire sys_safe_err5;
wire sys_safe_err6;
wire sys_safe_err7;
wire sys_safe_err8;
wire sys_safe_err9;
wire sys_safe_err10;
wire sys_safe_err11;
wire sys_safe_err12;
wire sys_safe_err13;
wire sys_safe_err14;
wire sys_safe_err15;
wire sys_safe_err16;
wire sys_safe_err17;
wire sys_safe_err18;
wire sys_safe_err19;
wire sys_safe_err;

wire env_fair0;
wire env_fair1;

wire sys_fair0;
wire sys_fair1;
wire sys_fair2;
wire sys_fair3;
wire all_env_fair_fulfilled;
wire all_sys_fair_fulfilled;
wire fair_err;
wire o_err;

// =============================================================
//                        ENV_TRANSITION:
// =============================================================
// Assumption 3:
// G( hlock0=1 -> hbusreq0=1 );
assign env_safe_err0 =  ~(~ i_hlock0 | i_hbusreq0);

// Assumption 3:
// G( hlock1=1 -> hbusreq1=1 );
assign env_safe_err1 =  ~(~ i_hlock1 | i_hbusreq1);

// collecting together the safety error bits:
assign env_safe_err = env_safe_err0 |
                      env_safe_err1;

// =============================================================
//                        SYS_TRANSITION:
// =============================================================
// G((hmaster0=0) -> (hbusreq0=0 <-> busreq=0));
assign sys_safe_err0 =  ~( ~( ~(controllable_hmaster0) )|(~i_hbusreq0 ^~ (~controllable_busreq)));

// G((hmaster0=1) -> (hbusreq1=0 <-> busreq=0));
assign sys_safe_err1 =  ~( ~( controllable_hmaster0 )|(~i_hbusreq1 ^~ (~controllable_busreq)));

// Guarantee 1:
// G((hready=0) -> X(start=0));
assign sys_safe_err2 =  ~( reg_i_hready | controllable_nstart );

// G(((stateG2=1) * (start=1)) -> FALSE;
assign sys_safe_err3 =  ~( ~(reg_stateG2 & ~controllable_nstart) | 0 );

// G(((stateG3_0=1) * (stateG3_1=0) * (stateG3_2=0) * ((start=1))) -> FALSE);
// G(((stateG3_0=0) * (stateG3_1=1) * (stateG3_2=0) * ((start=1))) -> FALSE);
// G(((stateG3_0=1) * (stateG3_1=1) * (stateG3_2=0) * ((start=1))) -> FALSE);
// G(((stateG3_0=0) * (stateG3_1=0) * (stateG3_2=1) * ((start=1))) -> FALSE);
// all these rules can be summarized as: only in state 000, start=1 is allowed:
assign sys_safe_err4 =  (reg_stateG3_0 | reg_stateG3_1 | reg_stateG3_2) & ~controllable_nstart;

// G( (hready=1) -> (   (hgrant0=1) <-> (X(hmaster0=0))  ) );
assign sys_safe_err5 =  ~( ~(reg_i_hready) | ( ~reg_controllable_nhgrant0 ^~ ( ~(controllable_hmaster0) ) ) );

// G( (hready=1) -> (   (hgrant1=1) <-> (X(hmaster0=1))  ) );
assign sys_safe_err6 =  ~( ~(reg_i_hready) | ( reg_controllable_hgrant1 ^~ ( controllable_hmaster0 ) ) );

// HMASTLOCK:
// G(  (hready=1) -> (locked=0 <-> X(hmastlock=0) ) );
assign sys_safe_err7 =  ~( ~(reg_i_hready) | (~reg_controllable_locked ^~ ~controllable_hmastlock) );

// Master 0:
// G( X(start=0) -> ( ((hmaster0=0)) <-> (X(hmaster0=0)) ) );
assign sys_safe_err8 =  ~( ~(controllable_nstart) | ( ( ~(reg_controllable_hmaster0) ) ^~ ( ~(controllable_hmaster0) )) );

// Master 1:
// G( X(start=0) -> ( ((hmaster0=1)) <-> (X(hmaster0=1)) ) );
assign sys_safe_err9 =  ~( ~(controllable_nstart) | ( ( reg_controllable_hmaster0 ) ^~ ( controllable_hmaster0 )) );

// Guarantee 6.2:
// G( ((X(start=0))) -> ( (hmastlock=1) <-> X(hmastlock=1)) );
assign sys_safe_err10 =  ~( ~(controllable_nstart) | ( reg_controllable_hmastlock ^~ controllable_hmastlock) );

// G( (decide=1  *  hlock0=1  *  X(hgrant0=1) )->X(locked=1));
assign sys_safe_err11 =  ~( ~(~reg_controllable_ndecide & reg_i_hlock0 & ~controllable_nhgrant0) | (controllable_locked) );

// G((decide=1  *  hlock0=0  *  X(hgrant0=1))->X(locked=0));
assign sys_safe_err12 =  ~( ~(~reg_controllable_ndecide & ~reg_i_hlock0 & ~controllable_nhgrant0) | (~controllable_locked) );

// G( (decide=1  *  hlock1=1  *  X(hgrant1=1) )->X(locked=1));
assign sys_safe_err13 =  ~( ~(~reg_controllable_ndecide & reg_i_hlock1 & controllable_hgrant1) | (controllable_locked) );

// G((decide=1  *  hlock1=0  *  X(hgrant1=1))->X(locked=0));
assign sys_safe_err14 =  ~( ~(~reg_controllable_ndecide & ~reg_i_hlock1 & controllable_hgrant1) | (~controllable_locked) );

// G( (decide=0) -> (  ((hgrant0=0)<->X(hgrant0=0))  ));
assign sys_safe_err15 =  ~( ~(reg_controllable_ndecide) | (reg_controllable_nhgrant0 ^~ controllable_nhgrant0) );

// G( (decide=0) -> (  ((hgrant1=0)<->X(hgrant1=0))  ));
assign sys_safe_err16 =  ~( ~(reg_controllable_ndecide) | (~reg_controllable_hgrant1 ^~ ~controllable_hgrant1) );

// G((decide=0)->(locked=0 <-> X(locked=0)));
assign sys_safe_err17 =  ~( ~(reg_controllable_ndecide) | (~reg_controllable_locked ^~ ~controllable_locked) );

// G(((stateG10_1=1) * (((hgrant1=1)) * (hbusreq1=0)))->FALSE);
assign sys_safe_err18 =  ~( ~(reg_stateG10_1 & (controllable_hgrant1 & ~i_hbusreq1)) | 0 );

// default master
// G((decide=1  *  hbusreq0=0  *  hbusreq1=0) -> X(hgrant0=1));
assign sys_safe_err19 =  ~( ~(~reg_controllable_ndecide & (~reg_i_hbusreq0 & ~reg_i_hbusreq1)) | (~controllable_nhgrant0) );

// collecting together the safety error bits:
assign sys_safe_err = sys_safe_err0 |
                      sys_safe_err1 |
                      sys_safe_err2 |
                      sys_safe_err3 |
                      sys_safe_err4 |
                      sys_safe_err5 |
                      sys_safe_err6 |
                      sys_safe_err7 |
                      sys_safe_err8 |
                      sys_safe_err9 |
                      sys_safe_err10 |
                      sys_safe_err11 |
                      sys_safe_err12 |
                      sys_safe_err13 |
                      sys_safe_err14 |
                      sys_safe_err15 |
                      sys_safe_err16 |
                      sys_safe_err17 |
                      sys_safe_err18 |
                      sys_safe_err19;

// =============================================================
//                          ENV_FAIRNESS:
// =============================================================
// Assumption 1: 
// G(F(stateA1=0));
assign env_fair0 =  ~reg_stateA1;

// Assumption 2:
// G(F(hready=1));
assign env_fair1 =  i_hready;

assign all_env_fair_fulfilled = (env_fair0done | env_fair0) &
                                (env_fair1done | env_fair1);

// =============================================================
//                          SYS_FAIRNESS:
// =============================================================
// Guarantee 2:
// G(F(stateG2=0));
assign sys_fair0 = ~reg_stateG2;

// Guarantee 3:
// G(F((stateG3_0=0)  *  (stateG3_1=0)  *  (stateG3_2=0)));
assign sys_fair1 =  (~reg_stateG3_0 & ~reg_stateG3_1 & ~reg_stateG3_2);

// G(F(((hmaster0=0))  |  hbusreq0=0));
assign sys_fair2 =  ( ~(controllable_hmaster0) ) | ~i_hbusreq0;

// G(F(((hmaster0=1))  |  hbusreq1=0));
assign sys_fair3 =  ( controllable_hmaster0 ) | ~i_hbusreq1;

assign all_sys_fair_fulfilled = (sys_fair0done | sys_fair0) &
                                (sys_fair1done | sys_fair1) &
                                (sys_fair2done | sys_fair2) &
                                (sys_fair3done | sys_fair3);
assign fair_err = (fair_cnt >= 6'b110010);

// computing the error output bit:
assign o_err = ~env_safe_err & ~env_safe_err_happened & (sys_safe_err | fair_err);

initial
 begin
  reg_i_hready = 0;
  reg_i_hbusreq0 = 0;
  reg_i_hlock0 = 0;
  reg_i_hbusreq1 = 0;
  reg_i_hlock1 = 0;
  reg_controllable_hmaster0 = 0;
  reg_controllable_hmastlock = 0;
  reg_controllable_nstart = 0;
  reg_controllable_ndecide = 0;
  reg_controllable_locked = 0;
  reg_controllable_nhgrant0 = 0;
  reg_controllable_hgrant1 = 0;
  reg_controllable_busreq = 0;
  reg_stateA1 = 0;
  reg_stateG2 = 0;
  reg_stateG3_0 = 0;
  reg_stateG3_1 = 0;
  reg_stateG3_2 = 0;
  reg_stateG10_1 = 0;
  env_safe_err_happened = 0;
  env_fair0done = 0;
  env_fair1done = 0;
  sys_fair0done = 0;
  sys_fair1done = 0;
  sys_fair2done = 0;
  sys_fair3done = 0;
  fair_cnt = 0;
 end


always @(posedge i_clk)
 begin
   // We remember if an environment error occurred:
   env_safe_err_happened = env_safe_err_happened | env_safe_err;

   // Updating the fairness counters: 
   if(all_sys_fair_fulfilled)
    begin
      env_fair0done = 0;
      env_fair1done = 0;
      sys_fair0done = 0;
      sys_fair1done = 0;
      sys_fair2done = 0;
      sys_fair3done = 0;
      fair_cnt = 0;
    end
   else
    begin
      sys_fair0done = sys_fair0done | sys_fair0;
      sys_fair1done = sys_fair1done | sys_fair1;
      sys_fair2done = sys_fair2done | sys_fair2;
      sys_fair3done = sys_fair3done | sys_fair3;
      if(all_env_fair_fulfilled)
       begin
         env_fair0done = 0;
         env_fair1done = 0;
         fair_cnt = fair_cnt + 1;
       end
      else
       begin
         env_fair0done = env_fair0done | env_fair0;
         env_fair1done = env_fair1done | env_fair1;
       end
    end

   // Updating the automata: 
   // Automaton A1: 
   if(~reg_stateA1 & controllable_hmastlock & ~i_hburst0 & ~i_hburst1)
    begin
      reg_stateA1 = 1'b1;
    end
   else if(reg_stateA1 & ~controllable_busreq)
    begin
      reg_stateA1 = 1'b0;
    end

   // Automaton G2: 
   if(~reg_stateG2)
    begin
      if(controllable_hmastlock & ~controllable_nstart & ~i_hburst0 & ~i_hburst1)
       begin
         reg_stateG2 = 1'b1;
       end
    end
   else // if(reg_stateG2)
    begin
      if(~controllable_busreq)
       begin
         reg_stateG2 = 1'b0;
       end
    end

   // Automaton G3: 
   if(~reg_stateG3_0 & ~reg_stateG3_1 & ~reg_stateG3_2 & controllable_hmastlock & ~controllable_nstart &  ~i_hburst0 & i_hburst1 & ~i_hready)
    begin
      reg_stateG3_0 = 1'b1;
      reg_stateG3_1 = 1'b0;
      reg_stateG3_2 = 1'b0;
    end
   else if(~reg_stateG3_0 & ~reg_stateG3_1 & ~reg_stateG3_2 & controllable_hmastlock & ~controllable_nstart &  ~i_hburst0 & i_hburst1 & i_hready)
    begin
      reg_stateG3_0 = 1'b0;
      reg_stateG3_1 = 1'b1;
      reg_stateG3_2 = 1'b0;
    end
   else if(reg_stateG3_0 & ~reg_stateG3_1 & ~reg_stateG3_2 & i_hready)
    begin
      reg_stateG3_0 = 1'b0;
      reg_stateG3_1 = 1'b1;
      reg_stateG3_2 = 1'b0;
    end
   else if(~reg_stateG3_0 & reg_stateG3_1 & ~reg_stateG3_2 & i_hready)
    begin
      reg_stateG3_0 = 1'b1;
      reg_stateG3_1 = 1'b1;
      reg_stateG3_2 = 1'b0;
    end
   else if(reg_stateG3_0 & reg_stateG3_1 & ~reg_stateG3_2 & i_hready)
    begin
      reg_stateG3_0 = 1'b0;
      reg_stateG3_1 = 1'b0;
      reg_stateG3_2 = 1'b1;
    end
   else if(~reg_stateG3_0 & ~reg_stateG3_1 & reg_stateG3_2 & i_hready)
    begin
      reg_stateG3_0 = 1'b0;
      reg_stateG3_1 = 1'b0;
      reg_stateG3_2 = 1'b0;
    end

   // Automaton G10_1: 
   if(~reg_stateG10_1 & ~controllable_hgrant1 & ~i_hbusreq1)
    begin
      reg_stateG10_1 = 1'b1;
    end
   else if(reg_stateG10_1 & i_hbusreq1)
    begin
      reg_stateG10_1 = 1'b0;
    end

   // Latching the previous input:
   reg_i_hready =  i_hready;
   reg_i_hbusreq0 =  i_hbusreq0;
   reg_i_hlock0 =  i_hlock0;
   reg_i_hbusreq1 =  i_hbusreq1;
   reg_i_hlock1 =  i_hlock1;
   reg_controllable_hmaster0 =  controllable_hmaster0;
   reg_controllable_hmastlock =  controllable_hmastlock;
   reg_controllable_nstart =  controllable_nstart;
   reg_controllable_ndecide =  controllable_ndecide;
   reg_controllable_locked =  controllable_locked;
   reg_controllable_nhgrant0 =  controllable_nhgrant0;
   reg_controllable_hgrant1 =  controllable_hgrant1;
   reg_controllable_busreq =  controllable_busreq;

 end
endmodule

-------------------------------
#!SYNTCOMP
STATUS : realizable
SOLVED_BY : 3/3 [2015-pre-classification]
SOLVED_IN : 0.215544 [2015-pre-classification]
#.
