aag 429 15 28 1 386
2
4
6
8
10
12
14
16
18
20
22
24
26
28
30
32 1
34 511
36 595
38 14
40 619
42 28
44 639
46 2
48 24
50 8
52 4
54 669
56 691
58 30
60 715
62 6
64 753
66 759
68 765
70 22
72 847
74 853
76 859
78 99
80 18
82 26
84 20
86 16
404
88 18 3
90 22 5
92 91 89
94 79 32
96 95 32
98 97 92
100 25 2
102 24 3
104 103 101
106 105 17
108 25 4
110 24 5
112 111 109
114 113 16
116 115 107
118 83 32
120 82 32
122 119 32
124 123 9
126 125 116
128 55 32
130 54 32
132 129 32
134 130 9
136 135 126
138 37 32
140 36 32
142 139 32
144 41 32
146 40 32
148 145 32
150 149 143
152 45 32
154 44 32
156 153 32
158 157 150
160 159 9
162 161 136
164 59 32
166 58 32
168 165 32
170 166 17
172 169 16
174 173 171
176 175 120
178 177 162
180 85 32
182 84 32
184 181 32
186 185 16
188 182 17
190 189 187
192 191 120
194 193 178
196 39 32
198 38 32
200 197 32
202 198 7
204 201 6
206 205 203
208 207 120
210 209 194
212 87 32
214 86 32
216 213 32
218 214 17
220 217 16
222 221 219
224 223 8
226 225 210
228 226 225
230 63 32
232 62 32
234 231 32
236 235 6
238 232 7
240 239 237
242 241 8
244 243 228
246 43 32
248 42 32
250 247 32
252 81 32
254 80 32
256 253 32
258 254 251
260 258 31
262 260 15
264 263 244
266 257 251
268 266 31
270 268 14
272 271 264
274 71 32
276 70 32
278 275 32
280 276 251
282 280 20
284 282 15
286 285 272
288 279 251
290 288 20
292 290 14
294 293 286
296 169 30
298 166 31
300 299 297
302 301 248
304 303 294
306 182 21
308 185 20
310 309 307
312 311 248
314 313 304
316 198 15
318 201 14
320 319 317
322 321 248
324 323 314
326 57 32
328 56 32
330 327 32
332 20 5
334 332 328
336 335 324
338 47 32
340 339 32
342 53 32
344 343 32
346 345 341
348 346 251
350 348 30
352 351 336
354 77 32
356 76 32
358 355 32
360 75 32
362 74 32
364 361 32
366 73 32
368 72 32
370 367 32
372 371 365
374 373 364
376 374 370
378 377 359
380 379 358
382 380 376
384 370 365
386 371 362
388 387 385
390 376 359
392 377 356
394 393 391
396 388 370
398 396 394
400 399 383
402 400 352
404 403 98
406 65 32
408 64 32
410 407 32
412 67 32
414 66 32
416 413 32
418 68 32
420 415 409
422 420 419
424 422 133
426 415 410
428 426 419
430 428 158
432 416 409
434 432 419
436 16 2
438 437 434
440 416 410
442 440 419
444 17 4
446 445 442
448 35 32
450 34 32
452 449 32
454 61 32
456 60 32
458 455 32
460 459 453
462 450 26
464 430 425
466 465 425
468 431 425
470 468 438
472 471 466
474 468 439
476 474 446
478 477 472
480 474 447
482 480 460
484 483 478
486 480 461
488 486 462
490 489 484
492 463 450
494 492 461
496 495 461
498 497 447
500 498 439
502 500 431
504 502 425
506 504 491
508 490 450
510 509 507
512 158 6
514 512 9
516 514 13
518 516 10
520 518 27
522 518 26
524 149 140
526 524 157
528 526 26
530 146 143
532 530 157
534 532 26
536 146 140
538 536 157
540 538 26
542 154 150
544 542 26
546 522 521
548 547 521
550 523 521
552 550 528
554 553 548
556 550 529
558 556 534
560 559 554
562 556 535
564 562 540
566 565 560
568 562 541
570 568 544
572 571 566
574 545 140
576 574 541
578 576 535
580 579 535
582 581 529
584 582 523
586 584 521
588 587 521
590 589 573
592 572 140
594 593 591
596 545 146
598 596 541
600 598 535
602 601 535
604 603 529
606 605 529
608 607 523
610 609 523
612 611 521
614 612 573
616 572 146
618 617 615
620 545 154
622 620 541
624 623 541
626 625 535
628 626 529
630 628 523
632 630 521
634 632 573
636 572 154
638 637 635
640 9 6
642 640 13
644 642 11
646 644 133
648 130 25
650 649 647
652 645 130
654 653 645
656 130 24
658 655 133
660 656 130
662 661 659
664 663 651
666 650 130
668 667 665
670 331 21
672 670 5
674 328 4
676 674 673
678 677 673
680 675 328
682 680 673
684 683 673
686 685 679
688 678 328
690 689 687
692 459 6
694 692 13
696 694 11
698 456 25
700 698 697
702 701 697
704 699 456
706 704 697
708 707 697
710 709 703
712 702 456
714 713 711
716 447 408
718 716 439
720 719 439
722 721 431
724 722 425
726 725 425
728 447 414
730 728 439
732 731 439
734 733 431
736 735 431
738 737 425
740 447 418
742 740 439
744 742 431
746 744 425
748 727 479
750 478 408
752 751 749
754 738 479
756 478 414
758 757 755
760 746 479
762 478 418
764 763 761
766 489 478
768 462 371
770 463 368
772 771 769
774 460 368
776 773 461
778 777 775
780 779 447
782 780 439
784 782 431
786 784 425
788 368 365
790 369 362
792 791 789
794 793 462
796 463 362
798 797 795
800 460 362
802 799 461
804 803 801
806 805 447
808 806 439
810 808 431
812 810 425
814 368 362
816 814 359
818 815 356
820 819 817
822 821 462
824 463 356
826 825 823
828 460 356
830 827 461
832 831 829
834 833 447
836 834 439
838 836 431
840 838 425
842 786 767
844 766 368
846 845 843
848 812 767
850 766 362
852 851 849
854 840 767
856 766 356
858 857 855
i0 i_hbusreq0
i1 i_hbusreq1
i2 controllable_hmastlock
i3 controllable_nstart
i4 i_hburst1
i5 i_hburst0
i6 controllable_locked
i7 controllable_hmaster0
i8 i_hlock0
i9 controllable_hgrant1
i10 i_hlock1
i11 controllable_busreq
i12 i_hready
i13 controllable_ndecide
i14 controllable_nhgrant0
l0 n33
l1 next_env_fair_out
l2 reg_stateG3_0_out
l3 reg_controllable_locked_out
l4 reg_stateG3_1_out
l5 reg_controllable_ndecide_out
l6 reg_stateG3_2_out
l7 reg_i_hbusreq0_out
l8 reg_controllable_busreq_out
l9 reg_controllable_nstart_out
l10 reg_i_hbusreq1_out
l11 reg_stateG2_out
l12 reg_stateG10_1_out
l13 reg_controllable_nhgrant0_out
l14 reg_stateA1_out
l15 reg_controllable_hmastlock_out
l16 next_sys_fair<0>_out
l17 next_sys_fair<1>_out
l18 next_sys_fair<2>_out
l19 reg_i_hlock1_out
l20 fair_cnt<0>_out
l21 fair_cnt<1>_out
l22 fair_cnt<2>_out
l23 env_safe_err_happened_out
l24 reg_i_hlock0_out
l25 reg_i_hready_out
l26 reg_controllable_hgrant1_out
l27 reg_controllable_hmaster0_out
o0 o_err
c
amba_2_new_7
This file was written by ABC on Sat Aug 31 20:24:57 2013
For information about AIGER format, refer to http://fmv.jku.at/aiger
-------------------------------
This AIGER file has been created by the following sequence of commands:
> vl2mv amba2c7.v   ---gives--> amba2c7.mv
> abc -c "read_blif_mv amba2c7.mv; write_aiger -s amba2c7n.aig"   ---gives--> amba2c7n.aig
> aigtoaig amba2c7n.aig amba2c7n.aag   ---gives--> amba2c7n.aag (this file)
Content of amba2c7.v:
module amba_2_new_7(
        o_err,
        i_clk,
        i_hready,
        i_hbusreq0,
        i_hlock0,
        i_hbusreq1,
        i_hlock1,
        i_hburst0,
        i_hburst1,
        controllable_hmaster0,
        controllable_hmastlock,
        controllable_nstart,
        controllable_ndecide,
        controllable_locked,
        controllable_nhgrant0,
        controllable_hgrant1,
        controllable_busreq);

input i_clk;
input i_hready;
input i_hbusreq0;
input i_hlock0;
input i_hbusreq1;
input i_hlock1;
input i_hburst0;
input i_hburst1;
input controllable_hmaster0;
input controllable_hmastlock;
input controllable_nstart;
input controllable_ndecide;
input controllable_locked;
input controllable_nhgrant0;
input controllable_hgrant1;
input controllable_busreq;
output o_err;

reg reg_i_hready;
reg reg_i_hbusreq0;
reg reg_i_hlock0;
reg reg_i_hbusreq1;
reg reg_i_hlock1;
reg reg_controllable_hmaster0;
reg reg_controllable_hmastlock;
reg reg_controllable_nstart;
reg reg_controllable_ndecide;
reg reg_controllable_locked;
reg reg_controllable_nhgrant0;
reg reg_controllable_hgrant1;
reg reg_controllable_busreq;
reg reg_stateA1;
reg reg_stateG2;
reg reg_stateG3_0;
reg reg_stateG3_1;
reg reg_stateG3_2;
reg reg_stateG10_1;
reg env_safe_err_happened;
reg next_env_fair;
reg [2:0] fair_cnt;
reg [2:0] next_sys_fair;

wire env_safe_err0;
wire env_safe_err1;
wire env_safe_err;

wire sys_safe_err0;
wire sys_safe_err1;
wire sys_safe_err2;
wire sys_safe_err3;
wire sys_safe_err4;
wire sys_safe_err5;
wire sys_safe_err6;
wire sys_safe_err7;
wire sys_safe_err8;
wire sys_safe_err9;
wire sys_safe_err10;
wire sys_safe_err11;
wire sys_safe_err12;
wire sys_safe_err13;
wire sys_safe_err14;
wire sys_safe_err15;
wire sys_safe_err16;
wire sys_safe_err17;
wire sys_safe_err18;
wire sys_safe_err19;
wire sys_safe_err;

wire env_fair0;
wire env_fair1;

wire sys_fair0;
wire sys_fair1;
wire sys_fair2;
wire sys_fair3;
wire fair_err;
wire o_err;

// =============================================================
//                        ENV_TRANSITION:
// =============================================================
// Assumption 3:
// G( hlock0=1 -> hbusreq0=1 );
assign env_safe_err0 =  ~(~ i_hlock0 | i_hbusreq0);

// Assumption 3:
// G( hlock1=1 -> hbusreq1=1 );
assign env_safe_err1 =  ~(~ i_hlock1 | i_hbusreq1);

// collecting together the safety error bits:
assign env_safe_err = env_safe_err0 |
                      env_safe_err1;

// =============================================================
//                        SYS_TRANSITION:
// =============================================================
// G((hmaster0=0) -> (hbusreq0=0 <-> busreq=0));
assign sys_safe_err0 =  ~( ~( ~(controllable_hmaster0) )|(~i_hbusreq0 ^~ (~controllable_busreq)));

// G((hmaster0=1) -> (hbusreq1=0 <-> busreq=0));
assign sys_safe_err1 =  ~( ~( controllable_hmaster0 )|(~i_hbusreq1 ^~ (~controllable_busreq)));

// Guarantee 1:
// G((hready=0) -> X(start=0));
assign sys_safe_err2 =  ~( reg_i_hready | controllable_nstart );

// G(((stateG2=1) * (start=1)) -> FALSE;
assign sys_safe_err3 =  ~( ~(reg_stateG2 & ~controllable_nstart) | 0 );

// G(((stateG3_0=1) * (stateG3_1=0) * (stateG3_2=0) * ((start=1))) -> FALSE);
// G(((stateG3_0=0) * (stateG3_1=1) * (stateG3_2=0) * ((start=1))) -> FALSE);
// G(((stateG3_0=1) * (stateG3_1=1) * (stateG3_2=0) * ((start=1))) -> FALSE);
// G(((stateG3_0=0) * (stateG3_1=0) * (stateG3_2=1) * ((start=1))) -> FALSE);
// all these rules can be summarized as: only in state 000, start=1 is allowed:
assign sys_safe_err4 =  (reg_stateG3_0 | reg_stateG3_1 | reg_stateG3_2) & ~controllable_nstart;

// G( (hready=1) -> (   (hgrant0=1) <-> (X(hmaster0=0))  ) );
assign sys_safe_err5 =  ~( ~(reg_i_hready) | ( ~reg_controllable_nhgrant0 ^~ ( ~(controllable_hmaster0) ) ) );

// G( (hready=1) -> (   (hgrant1=1) <-> (X(hmaster0=1))  ) );
assign sys_safe_err6 =  ~( ~(reg_i_hready) | ( reg_controllable_hgrant1 ^~ ( controllable_hmaster0 ) ) );

// HMASTLOCK:
// G(  (hready=1) -> (locked=0 <-> X(hmastlock=0) ) );
assign sys_safe_err7 =  ~( ~(reg_i_hready) | (~reg_controllable_locked ^~ ~controllable_hmastlock) );

// Master 0:
// G( X(start=0) -> ( ((hmaster0=0)) <-> (X(hmaster0=0)) ) );
assign sys_safe_err8 =  ~( ~(controllable_nstart) | ( ( ~(reg_controllable_hmaster0) ) ^~ ( ~(controllable_hmaster0) )) );

// Master 1:
// G( X(start=0) -> ( ((hmaster0=1)) <-> (X(hmaster0=1)) ) );
assign sys_safe_err9 =  ~( ~(controllable_nstart) | ( ( reg_controllable_hmaster0 ) ^~ ( controllable_hmaster0 )) );

// Guarantee 6.2:
// G( ((X(start=0))) -> ( (hmastlock=1) <-> X(hmastlock=1)) );
assign sys_safe_err10 =  ~( ~(controllable_nstart) | ( reg_controllable_hmastlock ^~ controllable_hmastlock) );

// G( (decide=1  *  hlock0=1  *  X(hgrant0=1) )->X(locked=1));
assign sys_safe_err11 =  ~( ~(~reg_controllable_ndecide & reg_i_hlock0 & ~controllable_nhgrant0) | (controllable_locked) );

// G((decide=1  *  hlock0=0  *  X(hgrant0=1))->X(locked=0));
assign sys_safe_err12 =  ~( ~(~reg_controllable_ndecide & ~reg_i_hlock0 & ~controllable_nhgrant0) | (~controllable_locked) );

// G( (decide=1  *  hlock1=1  *  X(hgrant1=1) )->X(locked=1));
assign sys_safe_err13 =  ~( ~(~reg_controllable_ndecide & reg_i_hlock1 & controllable_hgrant1) | (controllable_locked) );

// G((decide=1  *  hlock1=0  *  X(hgrant1=1))->X(locked=0));
assign sys_safe_err14 =  ~( ~(~reg_controllable_ndecide & ~reg_i_hlock1 & controllable_hgrant1) | (~controllable_locked) );

// G( (decide=0) -> (  ((hgrant0=0)<->X(hgrant0=0))  ));
assign sys_safe_err15 =  ~( ~(reg_controllable_ndecide) | (reg_controllable_nhgrant0 ^~ controllable_nhgrant0) );

// G( (decide=0) -> (  ((hgrant1=0)<->X(hgrant1=0))  ));
assign sys_safe_err16 =  ~( ~(reg_controllable_ndecide) | (~reg_controllable_hgrant1 ^~ ~controllable_hgrant1) );

// G((decide=0)->(locked=0 <-> X(locked=0)));
assign sys_safe_err17 =  ~( ~(reg_controllable_ndecide) | (~reg_controllable_locked ^~ ~controllable_locked) );

// G(((stateG10_1=1) * (((hgrant1=1)) * (hbusreq1=0)))->FALSE);
assign sys_safe_err18 =  ~( ~(reg_stateG10_1 & (controllable_hgrant1 & ~i_hbusreq1)) | 0 );

// default master
// G((decide=1  *  hbusreq0=0  *  hbusreq1=0) -> X(hgrant0=1));
assign sys_safe_err19 =  ~( ~(~reg_controllable_ndecide & (~reg_i_hbusreq0 & ~reg_i_hbusreq1)) | (~controllable_nhgrant0) );

// collecting together the safety error bits:
assign sys_safe_err = sys_safe_err0 |
                      sys_safe_err1 |
                      sys_safe_err2 |
                      sys_safe_err3 |
                      sys_safe_err4 |
                      sys_safe_err5 |
                      sys_safe_err6 |
                      sys_safe_err7 |
                      sys_safe_err8 |
                      sys_safe_err9 |
                      sys_safe_err10 |
                      sys_safe_err11 |
                      sys_safe_err12 |
                      sys_safe_err13 |
                      sys_safe_err14 |
                      sys_safe_err15 |
                      sys_safe_err16 |
                      sys_safe_err17 |
                      sys_safe_err18 |
                      sys_safe_err19;

// =============================================================
//                          ENV_FAIRNESS:
// =============================================================
// Assumption 1: 
// G(F(stateA1=0));
assign env_fair0 =  ~reg_stateA1;

// Assumption 2:
// G(F(hready=1));
assign env_fair1 =  i_hready;


// =============================================================
//                          SYS_FAIRNESS:
// =============================================================
// Guarantee 2:
// G(F(stateG2=0));
assign sys_fair0 = ~reg_stateG2;

// Guarantee 3:
// G(F((stateG3_0=0)  *  (stateG3_1=0)  *  (stateG3_2=0)));
assign sys_fair1 =  (~reg_stateG3_0 & ~reg_stateG3_1 & ~reg_stateG3_2);

// G(F(((hmaster0=0))  |  hbusreq0=0));
assign sys_fair2 =  ( ~(controllable_hmaster0) ) | ~i_hbusreq0;

// G(F(((hmaster0=1))  |  hbusreq1=0));
assign sys_fair3 =  ( controllable_hmaster0 ) | ~i_hbusreq1;

assign fair_err = (fair_cnt >= 3'b111);

// computing the error output bit:
assign o_err = ~env_safe_err & ~env_safe_err_happened & (sys_safe_err | fair_err);

initial
 begin
  reg_i_hready = 0;
  reg_i_hbusreq0 = 0;
  reg_i_hlock0 = 0;
  reg_i_hbusreq1 = 0;
  reg_i_hlock1 = 0;
  reg_controllable_hmaster0 = 0;
  reg_controllable_hmastlock = 0;
  reg_controllable_nstart = 0;
  reg_controllable_ndecide = 0;
  reg_controllable_locked = 0;
  reg_controllable_nhgrant0 = 0;
  reg_controllable_hgrant1 = 0;
  reg_controllable_busreq = 0;
  reg_stateA1 = 0;
  reg_stateG2 = 0;
  reg_stateG3_0 = 0;
  reg_stateG3_1 = 0;
  reg_stateG3_2 = 0;
  reg_stateG10_1 = 0;
  env_safe_err_happened = 0;
  next_env_fair = 0;
  fair_cnt = 0;
  next_sys_fair = 0;
 end


always @(posedge i_clk)
 begin
   // We remember if an environment error occurred:
   env_safe_err_happened = env_safe_err_happened | env_safe_err;

   // Updating the fairness counters: 
   if((next_sys_fair == 0) & sys_fair0)
    begin
      next_sys_fair = 1;
      next_env_fair = 0;
      fair_cnt = 0;
    end
   else if((next_sys_fair == 1) & sys_fair1)
    begin
      next_sys_fair = 2;
      next_env_fair = 0;
      fair_cnt = 0;
    end
   else if((next_sys_fair == 2) & sys_fair2)
    begin
      next_sys_fair = 3;
      next_env_fair = 0;
      fair_cnt = 0;
    end
   else if((next_sys_fair == 3) & sys_fair3)
    begin
      next_sys_fair = 0;
      next_env_fair = 0;
      fair_cnt = 0;
    end
   else if(~next_env_fair & env_fair0)
    begin
      next_env_fair = 1;
    end
   else if(next_env_fair & env_fair1)
    begin
      next_env_fair = 0;
      fair_cnt = fair_cnt + 1;
    end

   // Updating the automata: 
   // Automaton A1: 
   if(~reg_stateA1 & controllable_hmastlock & ~i_hburst0 & ~i_hburst1)
    begin
      reg_stateA1 = 1'b1;
    end
   else if(reg_stateA1 & ~controllable_busreq)
    begin
      reg_stateA1 = 1'b0;
    end

   // Automaton G2: 
   if(~reg_stateG2)
    begin
      if(controllable_hmastlock & ~controllable_nstart & ~i_hburst0 & ~i_hburst1)
       begin
         reg_stateG2 = 1'b1;
       end
    end
   else // if(reg_stateG2)
    begin
      if(~controllable_busreq)
       begin
         reg_stateG2 = 1'b0;
       end
    end

   // Automaton G3: 
   if(~reg_stateG3_0 & ~reg_stateG3_1 & ~reg_stateG3_2 & controllable_hmastlock & ~controllable_nstart &  ~i_hburst0 & i_hburst1 & ~i_hready)
    begin
      reg_stateG3_0 = 1'b1;
      reg_stateG3_1 = 1'b0;
      reg_stateG3_2 = 1'b0;
    end
   else if(~reg_stateG3_0 & ~reg_stateG3_1 & ~reg_stateG3_2 & controllable_hmastlock & ~controllable_nstart &  ~i_hburst0 & i_hburst1 & i_hready)
    begin
      reg_stateG3_0 = 1'b0;
      reg_stateG3_1 = 1'b1;
      reg_stateG3_2 = 1'b0;
    end
   else if(reg_stateG3_0 & ~reg_stateG3_1 & ~reg_stateG3_2 & i_hready)
    begin
      reg_stateG3_0 = 1'b0;
      reg_stateG3_1 = 1'b1;
      reg_stateG3_2 = 1'b0;
    end
   else if(~reg_stateG3_0 & reg_stateG3_1 & ~reg_stateG3_2 & i_hready)
    begin
      reg_stateG3_0 = 1'b1;
      reg_stateG3_1 = 1'b1;
      reg_stateG3_2 = 1'b0;
    end
   else if(reg_stateG3_0 & reg_stateG3_1 & ~reg_stateG3_2 & i_hready)
    begin
      reg_stateG3_0 = 1'b0;
      reg_stateG3_1 = 1'b0;
      reg_stateG3_2 = 1'b1;
    end
   else if(~reg_stateG3_0 & ~reg_stateG3_1 & reg_stateG3_2 & i_hready)
    begin
      reg_stateG3_0 = 1'b0;
      reg_stateG3_1 = 1'b0;
      reg_stateG3_2 = 1'b0;
    end

   // Automaton G10_1: 
   if(~reg_stateG10_1 & ~controllable_hgrant1 & ~i_hbusreq1)
    begin
      reg_stateG10_1 = 1'b1;
    end
   else if(reg_stateG10_1 & i_hbusreq1)
    begin
      reg_stateG10_1 = 1'b0;
    end

   // Latching the previous input:
   reg_i_hready =  i_hready;
   reg_i_hbusreq0 =  i_hbusreq0;
   reg_i_hlock0 =  i_hlock0;
   reg_i_hbusreq1 =  i_hbusreq1;
   reg_i_hlock1 =  i_hlock1;
   reg_controllable_hmaster0 =  controllable_hmaster0;
   reg_controllable_hmastlock =  controllable_hmastlock;
   reg_controllable_nstart =  controllable_nstart;
   reg_controllable_ndecide =  controllable_ndecide;
   reg_controllable_locked =  controllable_locked;
   reg_controllable_nhgrant0 =  controllable_nhgrant0;
   reg_controllable_hgrant1 =  controllable_hgrant1;
   reg_controllable_busreq =  controllable_busreq;

 end
endmodule

-------------------------------
#!SYNTCOMP
STATUS : realizable
SOLVED_BY : 7/8 [SYNTCOMP2014-RealSeq]
SOLVED_IN : 0.336021 [SYNTCOMP2014-RealSeq]
#.
